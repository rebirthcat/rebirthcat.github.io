<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="不积跬步无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="Elvis">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Elvis">
<meta property="og:description" content="不积跬步无以至千里">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Elvis">
<meta name="twitter:description" content="不积跬步无以至千里">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Elvis</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Elvis</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/页内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/页内存管理/" itemprop="url">页内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T09:39:02+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    本节内容介绍linux 内存管理系统的基本原理，介绍位图，物理内存池，虚拟内存池的概念以及实现，最后实现malloc_page这样一个按页分配内存的内核函数；本节的局限性：只能按页为单位进行内存的分配，只实现内核线程的页分配内存，细粒度的内存分配以及用户进程的内存分配会在后面的章节中给出实现</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="/images/IMG_0066.JPG" alt="IMG_0066.JPG"></p>
<ul>
<li>位图相当于一组资源的映射。位图的每一位和被管理的单位资源都是一一对应的关系，位图主要用来管理容量较大的资源。    </li>
<li>本节中的管理的单位资源就是一个自然页内存，位图本身的最核心的结构是字节数组，每个字节的每一位都代表一页内存，每个二进制位都有0和1两种状态，0表示该位对应的页内存是空闲状态，而1则表示被使用状态。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>bitmap的结构定义和函数声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LIB_KERNEL_BITMAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIB_KERNEL_BITMAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> btmp_bytes_len;</span><br><span class="line"><span class="comment">/* 在遍历位图时,整体上以字节为单位,细节上是以位为单位,所以此处位图的指针必须是单字节 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap* btmp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> bit_idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> cnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>bitmap操作函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将位图btmp初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap* btmp)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断bit_idx位是否为1,若为1则返回true，否则返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> bit_idx)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整用于索引数组下标</span></span><br><span class="line">   <span class="keyword">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余用于索引数组内的位</span></span><br><span class="line">   <span class="keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;	 <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line"><span class="comment">/* 先逐字节比较,蛮力法 */</span></span><br><span class="line">   <span class="keyword">while</span> (( <span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len)) &#123;</span><br><span class="line"><span class="comment">/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */</span></span><br><span class="line">      idx_byte++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">   <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len) &#123;  <span class="comment">// 若该内存池找不到可用空间		</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位，</span></span><br><span class="line"><span class="comment">  * 在该字节内逐位比对,返回空闲位的索引。*/</span></span><br><span class="line">   <span class="keyword">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">/* 和btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">   <span class="keyword">while</span> ((<span class="keyword">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte]) &#123; </span><br><span class="line">	 idx_bit++;</span><br><span class="line">   &#125;</span><br><span class="line">	 </span><br><span class="line">   <span class="keyword">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit;    <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">   <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);   <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">   <span class="keyword">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> count = <span class="number">1</span>;	      <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">   bit_idx_start = <span class="number">-1</span>;	      <span class="comment">// 先将其置为-1,若找不到连续的位就直接返回</span></span><br><span class="line">   <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit))) &#123;	 <span class="comment">// 若next_bit为0</span></span><br><span class="line">	 count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 count = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (count == cnt) &#123;	    <span class="comment">// 若找到连续的cnt个空位</span></span><br><span class="line">	 bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      next_bit++;          </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将位图btmp的bit_idx位设置为value */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap* btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span> </span>&#123;</span><br><span class="line">   ASSERT((value == <span class="number">0</span>) || (value == <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;    <span class="comment">// 向下取整用于索引数组下标</span></span><br><span class="line">   <span class="keyword">uint32_t</span> bit_odd  = bit_idx % <span class="number">8</span>;    <span class="comment">// 取余用于索引数组内的位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一般都会用个0x1这样的数对字节中的位操作,</span></span><br><span class="line"><span class="comment"> * 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/</span></span><br><span class="line">   <span class="keyword">if</span> (value) &#123;		      <span class="comment">// 如果value为1</span></span><br><span class="line">      btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;		      <span class="comment">// 若为0</span></span><br><span class="line">      btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>​    内核和用户进程分别运行在自己的地址空间，在保护模式的分页机制下，有虚拟、物理两种地址，操作系统有责任把这两种地址分别管理</p>
<h4 id="物理内存地址池"><a href="#物理内存地址池" class="headerlink" title="物理内存地址池"></a>物理内存地址池</h4><ul>
<li>物理内存池分成两部分，一部分只用来运行内核，称为内核物理内存池，另一部分只用来分配给用户进程，称作用户物理内存池</li>
<li>用户物理内存池和内核物理内存池各站一半</li>
<li>当用户内存池中的内存都被用户进程耗尽时，不能向内核内存池申请，而是直接返回“内存不足”，拒绝请求</li>
</ul>
<h4 id="虚拟内存地址池"><a href="#虚拟内存地址池" class="headerlink" title="虚拟内存地址池"></a>虚拟内存地址池</h4><ul>
<li>用户进程或者内核线程在运行时，都有申请内存的需求，操作系统接受请求后，在分页机制下，为用户进程或者内核在堆中选择一个空闲的虚拟地址，并找个空闲的物理地址作为虚拟地址映射，之后把这个虚拟地址返回给用户进程或者内核</li>
<li>对于所有的任务（用户进程或者内核）来说，他们都有各自的虚拟地址空间，因此需要为所有任务维护他们自己的虚拟地址池</li>
<li>内核申请内存时，从内核字节的虚拟地址池中分配虚拟地址，在从内核物理内存池(内核专用)中分配物理内存，然后在内核自己的页表将这两种地址建立好映射关系</li>
<li>用户进程向操作系统申请内存时，操作系统先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池（所有用户进程贡献）中分配空闲的物理内存，然后在该用户进程自己的页表中将这两种地址建立好映射关系</li>
<li>为方便实现和管理，虚拟地址池中的资源单位也是4KB，这样虚拟地址便和物理地址有了完整页的映射，有了虚拟地址池和物理地址池后，他们的关系下图</li>
</ul>
<p><img src="/images/IMG_0067.JPG" alt="IMG_0067.JPG"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>memory.h：定义内核池标记、页表项和目录项的属性位、虚拟地址池并声明初始化内存池、按页申请内存函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERNEL_MEMORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_MEMORY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存池标记,用于判断用哪个内存池 */</span></span><br><span class="line"><span class="keyword">enum</span> pool_flags &#123;</span><br><span class="line">   PF_KERNEL = <span class="number">1</span>,    <span class="comment">// 内核内存池</span></span><br><span class="line">   PF_USER = <span class="number">2</span>	     <span class="comment">// 用户内存池</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_P_1	  1	<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_P_0	  0	<span class="comment">// 页表项或页目录项存在属性位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_RW_R  0	<span class="comment">// R/W 属性位值, 读/执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_RW_W  2	<span class="comment">// R/W 属性位值, 读/写/执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_US_S  0	<span class="comment">// U/S 属性位值, 系统级</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	 PG_US_U  4	<span class="comment">// U/S 属性位值, 用户级</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于虚拟地址管理 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span></span><br><span class="line"><span class="comment">/* 虚拟地址用到的位图结构，用于记录哪些虚拟地址被占用了。以页为单位。*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span></span><br><span class="line"><span class="comment">/* 管理的虚拟地址 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malloc_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">uint32_t</span>* pte_ptr(<span class="keyword">uint32_t</span> vaddr);</span><br><span class="line"><span class="keyword">uint32_t</span>* pde_ptr(<span class="keyword">uint32_t</span> vaddr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>memory.c：定义用户和内核物理内存池，完成初始化、按页分配内存的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************  位图地址 ********************</span></span><br><span class="line"><span class="comment"> * 因为0xc009f000是内核主线程栈顶，0xc009e000是内核主线程的pcb.</span></span><br><span class="line"><span class="comment"> * 一个页框大小的位图可表示128M内存, 位图位置安排在地址0xc009a000,</span></span><br><span class="line"><span class="comment"> * 这样本系统最大支持4个页框的位图,即512M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="comment">/*************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000是内核从虚拟地址3G起. 0x100000意指跨过低端1M内存,使虚拟地址在逻辑上连续 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_HEAP_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存池结构,生成两个实例用于管理内核内存池和用户内存池 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span>	 <span class="comment">// 本内存池用到的位图结构,用于管理物理内存</span></span><br><span class="line">   <span class="keyword">uint32_t</span> phy_addr_start;	 <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> pool_size;		 <span class="comment">// 本内存池字节容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span>      <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span>	 <span class="comment">// 此结构是用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,</span></span><br><span class="line"><span class="comment"> * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">      bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">      <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(cnt &lt; pg_cnt) &#123;</span><br><span class="line">	 bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">   <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pte指针*/</span></span><br><span class="line"><span class="keyword">uint32_t</span>* pte_ptr(<span class="keyword">uint32_t</span> vaddr) &#123;</span><br><span class="line">   <span class="comment">/* 先访问到页表自己 + \</span></span><br><span class="line"><span class="comment">    * 再用页目录项pde(页目录内页表的索引)做为pte的索引访问到页表 + \</span></span><br><span class="line"><span class="comment">    * 再用pte的索引做为页内偏移*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* pte = (<span class="keyword">uint32_t</span>*)(<span class="number">0xffc00000</span> + \</span><br><span class="line">	 ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + \</span><br><span class="line">	 PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pde的指针 */</span></span><br><span class="line"><span class="keyword">uint32_t</span>* pde_ptr(<span class="keyword">uint32_t</span> vaddr) &#123;</span><br><span class="line">   <span class="comment">/* 0xfffff是用来访问到页表本身所在的地址 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* pde = (<span class="keyword">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在m_pool指向的物理内存池中分配1个物理页,</span></span><br><span class="line"><span class="comment"> * 成功则返回页框的物理地址,失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">palloc</span><span class="params">(struct pool* m_pool)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 扫描或设置位图要保证原子操作 */</span></span><br><span class="line">   <span class="keyword">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);    <span class="comment">// 找一个物理页面</span></span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);	<span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">   <span class="keyword">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span>* _vaddr, <span class="keyword">void</span>* _page_phyaddr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)_vaddr, page_phyaddr = (<span class="keyword">uint32_t</span>)_page_phyaddr;</span><br><span class="line">   <span class="keyword">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">   <span class="keyword">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">   <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">   <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;	 <span class="comment">// 页目录项和页表项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">      ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>)) &#123;   <span class="comment">// 只要是创建页表,pte就应该不存在,多判断一下放心</span></span><br><span class="line">	 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;			    <span class="comment">//应该不会执行到这，因为上面的ASSERT会先执行。</span></span><br><span class="line">	 PANIC(<span class="string">"pte repeat"</span>);</span><br><span class="line">	 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;			    <span class="comment">// 页目录项不存在,所以要先创建页目录再创建页表项.</span></span><br><span class="line">      <span class="comment">/* 页表中用到的页框一律从内核空间分配 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> pde_phyaddr = (<span class="keyword">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line"></span><br><span class="line">      *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">       * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">       * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">       * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">       * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">         </span><br><span class="line">      ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">   ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);</span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">*************************xiaog**************************************/</span></span><br><span class="line">   <span class="keyword">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> = <span class="title">pf</span> &amp; <span class="title">PF_KERNEL</span> ? &amp;<span class="title">kernel_pool</span> :</span> &amp;user_pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">   <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">      <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) &#123;  <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      page_table_add((<span class="keyword">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射 </span></span><br><span class="line">      vaddr += PG_SIZE;		 <span class="comment">// 下一个虚拟页</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>) &#123;	   <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">      <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化内存池 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_pool_init</span><span class="params">(<span class="keyword">uint32_t</span> all_mem)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"   mem_pool_init start\n"</span>);</span><br><span class="line">   <span class="keyword">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;	  <span class="comment">// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+</span></span><br><span class="line">                                                  <span class="comment">// 第769~1022个页目录项共指向254个页表,共256个页框</span></span><br><span class="line">   <span class="keyword">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;	  <span class="comment">// 0x100000为低端1M内存</span></span><br><span class="line">   <span class="keyword">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">   <span class="keyword">uint16_t</span> all_free_pages = free_mem / PG_SIZE;		  <span class="comment">// 1页为4k,不管总内存是不是4k的倍数,</span></span><br><span class="line">								  <span class="comment">// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。</span></span><br><span class="line">   <span class="keyword">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;			  <span class="comment">// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位</span></span><br><span class="line">   <span class="keyword">uint32_t</span> ubm_length = user_free_pages / <span class="number">8</span>;			  <span class="comment">// User BitMap的长度.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> kp_start = used_mem;				  <span class="comment">// Kernel Pool start,内核内存池的起始地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;	  <span class="comment">// User Pool start,用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">   kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">   user_pool.phy_addr_start   = up_start;</span><br><span class="line"></span><br><span class="line">   kernel_pool.pool_size = kernel_free_pages * PG_SIZE;</span><br><span class="line">   user_pool.pool_size	 = user_free_pages * PG_SIZE;</span><br><span class="line"></span><br><span class="line">   kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">   user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********    内核内存池和用户内存池位图   ***********</span></span><br><span class="line"><span class="comment"> *   位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment"> *   全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment"> *   而我们需要根据总内存大小算出需要多少字节。</span></span><br><span class="line"><span class="comment"> *   所以改为指定一块内存来生成位图.</span></span><br><span class="line"><span class="comment"> *   ************************************************/</span></span><br><span class="line"><span class="comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span></span><br><span class="line"><span class="comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span></span><br><span class="line">   kernel_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)MEM_BITMAP_BASE;</span><br><span class="line">							       </span><br><span class="line"><span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span></span><br><span class="line">   user_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line">   <span class="comment">/******************** 输出内存池信息 **********************/</span></span><br><span class="line">   put_str(<span class="string">"      kernel_pool_bitmap_start:"</span>);put_int((<span class="keyword">int</span>)kernel_pool.pool_bitmap.bits);</span><br><span class="line">   put_str(<span class="string">" kernel_pool_phy_addr_start:"</span>);put_int(kernel_pool.phy_addr_start);</span><br><span class="line">   put_str(<span class="string">"\n"</span>);</span><br><span class="line">   put_str(<span class="string">"      user_pool_bitmap_start:"</span>);put_int((<span class="keyword">int</span>)user_pool.pool_bitmap.bits);</span><br><span class="line">   put_str(<span class="string">" user_pool_phy_addr_start:"</span>);put_int(user_pool.phy_addr_start);</span><br><span class="line">   put_str(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将位图置0*/</span></span><br><span class="line">   bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">   bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span></span><br><span class="line">   kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;      <span class="comment">// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span></span><br><span class="line">   kernel_vaddr.vaddr_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line"></span><br><span class="line">   kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">   bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">   put_str(<span class="string">"   mem_pool_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理部分初始化入口 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"mem_init start\n"</span>);</span><br><span class="line">   <span class="keyword">uint32_t</span> mem_bytes_total = (*(<span class="keyword">uint32_t</span>*)(<span class="number">0xb00</span>));</span><br><span class="line">   mem_pool_init(mem_bytes_total);	  <span class="comment">// 初始化内存池</span></span><br><span class="line">   put_str(<span class="string">"mem_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c: init_all()中加入初始化内存池，然后向调用get_kernel_pages(3)向内核物理内存池申请3页大小的内存，并返回在内核虚拟内存池中的虚拟地址并打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span>* addr = get_kernel_pages(<span class="number">3</span>);</span><br><span class="line">   put_str(<span class="string">"\n get_kernel_page start vaddr is "</span>);</span><br><span class="line">   put_int((<span class="keyword">uint32_t</span>)addr);</span><br><span class="line">   put_str(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h4><p><img src="/images/IMG_0068.JPG" alt="IMG_0068.JPG"></p>
<ul>
<li>位图本身存在于低端1MB的0x0009a000处，距离内核PCB处有16kb的大小，即位图长度为16KB的字节数组，可以管理内存最大范围是512M，对于本系统来说是够用了</li>
<li>位图所管理的资源只能是“未被征用”的内存，而那些已经被提取征用的内存资源并不在位图的管理范围内，已经被“提取征用的资源”包括低端1MB内存，页目录表和255张内核页表（1MB），所以位图管理的内核物理地址最小是0x00200000</li>
<li>内核虚拟内存池的起始地址K_HEAP_START=0xc0100000，因为0xc000000~0xc0100000这1MB已经在初始化页表时映射到了物理地址低端1MB上，这1MB的虚拟地址已经被占用，内核后续的运行如果需要申请虚拟地址只能从0xc010000开始</li>
<li>通过以上分析可以得知，内核虚拟地址池的起始地址是0xc0100000，内核物理地址池的起始地址是0x00200000，所以如果内核第一次开始申请内存时，将返回0xc010000，而且会在内核页表中建立虚拟地址0xc010000到物理地址0x00200000的映射关系。通过bochs调试命令可以查看页表映射关系，见下图</li>
</ul>
<p><img src="/images/IMG_0069.JPG" alt="IMG_0069.JPG"></p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>​    完成本节后，系统的整体内存布局入下图</p>
<p><img src="/images/45.png" alt="45.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/中断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/16/中断/" itemprop="url">中断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-16T20:10:42+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="中断相关概念"><a href="#中断相关概念" class="headerlink" title="中断相关概念"></a>中断相关概念</h3><h4 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h4><ol>
<li>外部中断：来自CPU外部的中断，中断源通常是某个硬件，所以外部中断又称硬中断。CPU通过INTR和NMI两个中断信号线接受来自的外部中断，外部中断根据这两条信号线的不同又分为：<ul>
<li>可屏蔽中断：来自INTR向CPU发送的中断，键盘，硬盘，网卡，打印机等外设通过8259A的</li>
<li>不可屏蔽中断：来自NMI向CPU发送的中断，电源掉电，内存读写错误，总线奇偶校验错误</li>
</ul>
</li>
<li>内部中断：由CPU内部或者程序指令发起的中断，其中内部中断又分为：<ul>
<li>软中断：软件主动发起的中断，int指令发起的中断，系统调用就是通过int 80并将子功能号写入eax而发起的软中 断，int 3是调试段点指令，也是软中断，等等</li>
<li>异常：指令执行期间CPU内部产生的错误引起的，比如缺页异常，就是非常常见的内部中断，其对应一段中断处理程序，该程序可以将磁盘上的页重新加载到内存；比如除0错误，CPU在做除法运算时，发现分母为0，就会引发0号异常，也即0号中断</li>
<li>内部中断不可屏蔽，也就是说系统调用和异常都是不可屏蔽的中断</li>
</ul>
</li>
</ol>
<h4 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h4><ul>
<li>中断向量号是中断描述符表的索引，每个中断向量号对应一个中断描述符，每个中断描述符中记录该中断号对应的中断处理程序的段选择子和偏移量，通过这个选择子中GDT中索引得到段描述符，然后在通过偏移地址在该段中得到中段处理程序的入口地址</li>
<li>异常和不可屏蔽中断的中断向量号是有CPU自动提供，而来自外部设备的可屏蔽中断的中断号是由中断代理（8259A芯片）提供的，软中断是由程序指令提供的（比如系统调用的库函数中必然会有int 80这条汇编指令，80就是中断号，是内核代码或者说是操作系统提供的，操作系统本身也是软件，所以也叫软中断）</li>
</ul>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><h5 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h5><ul>
<li>可屏蔽中断是通过INTR引脚进入CPU的，外部设备如硬盘，网卡等发出的中断都是可屏蔽中断。即这些设备产生的中断CPU可以不必理会，因为它不会让系统宕机</li>
<li>通过eflags寄存器的IF位可以将这些外部设备的中断全部屏蔽，一般外设中断处理程序都分为上半部和下半部，上半部通常都是在关中断的情况下执行，因为上半部所要做的事情非常紧急，比如网卡的缓冲区通常较小，网络数据到达网卡缓冲区后，需要尽快的拷贝到内核缓冲区，否则网卡缓冲区一旦写满，后来的网络包将被丢弃</li>
</ul>
<h5 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h5><ul>
<li>不可屏蔽中断是通过NMI引脚进入CPU的，表示系统发生了致命的错误，之所以不可屏蔽是因为这些错误会导致系统停止运行。</li>
<li>常见的不可屏蔽的外部中断（或者叫错误）有断电，内存读写错误等</li>
<li>内部中断都是不可屏蔽的（系统调用和异常都是不可屏蔽中断的）</li>
</ul>
<p><img src="/images/36.jpg" alt="36.jpg"></p>
<h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p>​    中断描述符表（IDT）是保护模式下用于存储中断处理程序入口的表（数组），当CPU接受到一个中断时，通过中断向量号在IDT中索引对应的中断门描述符，在该门描述符中找到中断处理程序的段选择子和偏移地址，并进行相关的特权级检查，检查通过后执行中断处理程序</p>
<h4 id="中断门描述符"><a href="#中断门描述符" class="headerlink" title="中断门描述符"></a>中断门描述符</h4><p><img src="/images/37.jpg" alt="37.jpg"></p>
<p>​    中断门包含中断处理程序所在段的段选择子和段内偏移地址，通过中断门进行中断后，eflags中的IF位自动置0，也就是所有的中断处理程序在进入中断的那一刻都是默认屏蔽所有中断的。当然，可以通过某些指令在中断处理函数的内部就将eflags中的IF位置1，即打开中断(例如外设的中断处理程序上半部是在屏蔽中断的情况下执行的，下半部是在开中断情况下执行)</p>
<h4 id="中断描述表寄存器（IDTR）"><a href="#中断描述表寄存器（IDTR）" class="headerlink" title="中断描述表寄存器（IDTR）"></a>中断描述表寄存器（IDTR）</h4><ul>
<li>CPU内部有中断描述符表寄存器（IDTR），该寄存器48位，0<del>15位是表界限，16</del>47是中断描述符表的32位线性地址。16位表界限64KB，中断描述符8字节，所有最大支持64KB/8=8192个描述符，但是在32位系统中只支持256个描述符</li>
<li>设置IDTR的指令：lidt 48位内存数据</li>
</ul>
<h4 id="中断处理过程及特权检查"><a href="#中断处理过程及特权检查" class="headerlink" title="中断处理过程及特权检查"></a>中断处理过程及特权检查</h4><p>​    硬中断（外设中断）的过程通常分为CPU外部和CPU内部，CPU外部过程是外设想8259A发送信号，然后8259A将中断向量号发送给CPU的过程；CPU内部指的是CPU获得中断向量号后开始执行中断处理程序的过程。软中断和异常没有外部过程，只有内部过程，因为他们都是内部中断，中断向量号不需要中断代理提供。这里所讨论的中断处理过程只是内部过程，外部过程稍后在中断代理8259A的部分会有详细介绍</p>
<ol>
<li><p>处理器根据中断向量号定位中断门描述符：中断向量号*8+IDTR高32位</p>
</li>
<li><p>处理器进行特权级检查：</p>
<ul>
<li>如果是软中断，例如用户程序使用系统调用，则当前特权级必须在门描述符的DPL和门中目标代码段的DPL之间，即数值上  门中目标代码段的DPL&lt; 用户程序的CPL&lt;=门描述符的DPL</li>
<li>如果是外设和异常引起的中断，只检查CPL和门中目标代码段，要求CPL权限小于目标代码段DPL，即数值上CPL&gt;DPL</li>
</ul>
</li>
<li><p>中断发生后，eflags中IF位被值0，避免中断嵌套。默认情况下，处理器会在无人打扰的方式下执行中断处理函数，至于什么时候打开中断，由中断处理程序自己决定（即内核自己决定什么时候打开中断），CPU为内核提供可以随时开关中断指令：</p>
<ul>
<li>关中断指令：cli，将IF位置0</li>
<li>开中断指令：sti，将IF位置1</li>
</ul>
</li>
<li><p>中断处理程序执行之前进行任务现场保护，这在稍后会单独介绍</p>
</li>
<li><p>执行中断处理程序</p>
</li>
<li><p>中断返回，即iret指令，主要是对第4步中的任务进行恢复现场</p>
<p><img src="/images/38.jpg" alt="38.jpg"></p>
</li>
</ol>
<h4 id="中断现场保护"><a href="#中断现场保护" class="headerlink" title="中断现场保护"></a>中断现场保护</h4><h5 id="特权级发生变化"><a href="#特权级发生变化" class="headerlink" title="特权级发生变化"></a>特权级发生变化</h5><p>​    中断发生时，如果当前运行的是用户程序，比如用户程序通过80中断进行系统调用，当前任务的特权级会向高特权级转移，需要去TSS中寻找高特权级的栈，所以必须将原特权级的SS和EIP入栈到高特权级栈中，一下是具体要做的事情：</p>
<ol>
<li>处理器临时保存当前旧栈SS和EIP值，记作SS_old和EIP_old</li>
<li>在TSS段中找到新的高特权级栈，压入SS_old和EIP_old</li>
<li>在新栈中压入EFLAGS寄存器</li>
<li>由于要切换目标代码段，CS寄存器和EIP将被重新修改为中断处理函数的段选择子和偏移地址，所以为了恢复原任务的执行流程，要将CS_old和EIP_old压入新栈</li>
<li>某些异常会有错误码，则会压入ERROR_CODE</li>
</ol>
<p><img src="/images/39.png" alt="39.jpg"></p>
<h5 id="特权级不发生变化"><a href="#特权级不发生变化" class="headerlink" title="特权级不发生变化"></a>特权级不发生变化</h5><p>​    中断发生是，CPU处于内核态，且处于开中断状态，比如网卡中断的下半部的网络协议栈的处理过程中，CPU已经处于0特权级，使用的栈就是0特权级的栈，进入中断后，还是使用0特权级的栈，所以该情况下不需要压入SS_old和EIP_old，其他过程相同，最后栈的结果如下图：</p>
<p><img src="/images/41.jpg" alt="41.jpg"></p>
<h4 id="中断现场恢复"><a href="#中断现场恢复" class="headerlink" title="中断现场恢复"></a>中断现场恢复</h4><ul>
<li>中断返回指令iret，专用于从中断处理程序返回</li>
<li>中断返回指令是中断现场保护的逆过程，所以当执行iret前，一定要保证栈顶数据的正确性，且从栈顶往上的顺序是EIP,CS,EFLAGS,如果有特权级变化，还有ESP,SS</li>
<li>如果中断现场保护压入了错误码（异常中断），必须手动将其跳过，让栈顶指针指向错误码之上的EIP</li>
<li>当栈顶指针指向EIP后，执行iret将做如下动作：<ol>
<li>弹出EIP_old，CS_old,判断是否需要改变特权级，然后进行特权级检查，检查通过，加载到EIP，CS寄存器</li>
<li>弹出EFLAGS到eflags寄存器中</li>
<li>如果在第一步中判断处需要改变特权级，即往低特权级级转移，也就是需要恢复旧栈，则弹出ESP_old和SS_old到寄存器ESP和SS，并进行特权级检查</li>
<li>检查数据段寄存器DS，ES，FS和GS内容，如果他们之中，某个寄存器选择子所指向的数据段描述符的DPL权限比返回后的CPL（CS.RPL）高，处理器将吧数值0填充到相应的段寄存器</li>
</ol>
</li>
</ul>
<h3 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>用于管理和控制可屏蔽中断，即屏蔽外设中断，对多个外设同时到达的中断实行优先级判决，选出优先级最高的外设中断信号，并向CPU提供该外设中断信号对应的中断向量号，以上功能都可以通过编程实现</li>
</ul>
<h4 id="外部引脚信号线"><a href="#外部引脚信号线" class="headerlink" title="外部引脚信号线"></a>外部引脚信号线</h4><p><img src="/images/42.jpg" alt="42.jpg"></p>
<ul>
<li>intel处理器只能支持256个中断，一片8259A只支持8种外设中断，若要支持更多，只能采取多片级联的方式，个人计算机通常是两片8259A级联，一共支持8+8-1=15个中断（级联的从片占用主片一个IRQ引脚）</li>
<li>一个中断源对应一个中断引脚，一个中断引脚对应一个中断号，这个中断号的具体值可以通过编程方式进行初始化，当该引脚对应的外生的中断响应后，正常情况下8259A就会把这个引脚对应的中断向量号通过INRT引脚发送给CPU</li>
</ul>
<h4 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h4><p><img src="/images/43.jpg" alt="43.jpg"></p>
<p>​    下面对这些主要引脚和寄存器部件作用进行介绍：</p>
<ul>
<li>INT:8259A通过该信号线想CPU发送中断向量号</li>
<li>INTA:中断响应信号，8259A用其接受来自CPU的中断响应，这样8259A就可以处理其他外设的中断信号</li>
<li>IMR：中断屏蔽寄存器，用来屏蔽某个外设中断</li>
<li>IRR，中断请求寄存器，次寄存器中全是等待处理的中断，相当于未处理的中断信号队列</li>
<li>PR,优先级仲裁器，当有多个中断同时发生时，或有新的中断请求进来时，与正在处理的中断进行比较，找出优先级更高的中断</li>
<li>ISR：中断服务寄存器，当某个中断正常被处理时，保存次寄存器中</li>
<li>以上提到的寄存器都是8位，每一位正好对应8259A的8个IRQ引脚，类似位图，这样操作寄存器中的位便表示处理来自对应IRQ接口的中断信号</li>
</ul>
<h4 id="8259A的工作流程"><a href="#8259A的工作流程" class="headerlink" title="8259A的工作流程"></a>8259A的工作流程</h4><ol>
<li>外设发出中断信号到8259A，8259A检查IMR对应的位是否被屏蔽，如果被屏蔽丢弃该信号，否则下一步</li>
<li>将中断信号送如IRR寄存器，即该中断信号进入了“待处理队列”，即相应位置1</li>
<li>PR寄存器将从IRR寄存器中置1的所有位对应的中断信号中选择优先级最高的（时钟中断IRQ0的优先级最高，依次递减）</li>
<li>8259A通过INT引脚想CPU发出INTR信号，CPU知道有外部中断到来，执行完当前指令后，通过INTA接口向8259A发送中断响应信号，表示“我CPU已经准备好了，你可以继续后面的工作了”</li>
<li>8259A收到4步骤中CPU发来的中断响应信号，立即将刚选出来的优先级最高的中断在ISR中对应的位置1，同时将IRR寄存器中对应的位置0</li>
<li>CPU再次发送INTR信号给8259A，这次是向8259A索要中断向量号</li>
<li>8259A通过数据总线发送中断向量号给CPU</li>
<li>CPU拿到中断向量号后执行索引中断描述符，找到中断处理程序的入口地址并去执行</li>
<li>如果8259A的EOI通知设置为手动模式，CPU执行玩中断处理程序后向8259A发送EOI的代码，8259A收到EOI通知后，将ISR寄存器对应的位置0</li>
<li>如果8259A的EOI通知设置为自动模式，当8259A收到第二个INTA信号，也就是CPU索要中断向量号时，8259A会自动将次中断在ISR中对应的位置0</li>
</ol>
<h4 id="ISR中断替换"><a href="#ISR中断替换" class="headerlink" title="ISR中断替换"></a>ISR中断替换</h4><p>​    如果在8259A向CPU发送中断向量号之前，此时如果有新的更高优先级的中断到来，则原来ISR中相应的位恢复为0，随后在ISR中将此优先级更高的新中断的位置1，然后将新中断的中断向量号发送给CPU。所以即使某些低优先级的中断信号，经过第一次PR寄存器的选择进入ISR后，仍有肯能被后来的更高优先级的中断信号替换</p>
<h4 id="8259A编程"><a href="#8259A编程" class="headerlink" title="8259A编程"></a>8259A编程</h4><p>​    8259A的通用名叫可编程中断控制器，所谓的可编程就是内核可以通过指令设置8259A的中断向量号，例如设置IRQ0～IRQ7这8个引脚分别对应的中断向量号，又例如设置8259A的工作方式，像中断检测方式，是否级联，EOI通知方式等等</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><h4 id="内核启动中断流程"><a href="#内核启动中断流程" class="headerlink" title="内核启动中断流程"></a>内核启动中断流程</h4><p><img src="/images/44.jpg" alt="44.jpg"></p>
<ul>
<li>init_all 是内核用来初始化的函数，其中包括idt_init()初始化中断处理程序，</li>
<li>idt_init()包括初始化8259A的pic_init()和初始化中断描述符表（也包括中断处理函数，只不过是mock函数，只用来进行演示中断发生）的idt_desc_init()</li>
<li>最后加载IDT，也就是设置IDTR寄存器的值，用来让CPU获取中断描述表的基地址和界限</li>
</ul>
<h4 id="中断处理程序入口"><a href="#中断处理程序入口" class="headerlink" title="中断处理程序入口"></a>中断处理程序入口</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="meta">%define</span> ERROR_CODE <span class="keyword">nop</span>		 <span class="comment">; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span></span><br><span class="line"><span class="meta">%define</span> <span class="meta">ZERO</span> <span class="keyword">push</span> <span class="number">0</span>		 <span class="comment">; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">extern</span> idt_table		 <span class="comment">;idt_table是C中注册的中断处理程序数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line"><span class="meta">global</span> intr_entry_table</span><br><span class="line"><span class="symbol">intr_entry_table:</span></span><br><span class="line"></span><br><span class="line">%macro VECTOR <span class="number">2</span></span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line">intr<span class="subst">%1</span>entry:		 <span class="comment">; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少</span></span><br><span class="line"></span><br><span class="line">   <span class="subst">%2</span>				 <span class="comment">; 中断若有错误码会压在eip后面 </span></span><br><span class="line"><span class="comment">; 以下是保存上下文环境</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">fs</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">gs</span></span><br><span class="line">   <span class="keyword">pushad</span>			 <span class="comment">; PUSHAD指令压入32位寄存器,其入栈顺序是: EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI </span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                   <span class="comment">; 中断结束命令EOI</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0xa0</span>,<span class="built_in">al</span>                   <span class="comment">; 向从片发送</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x20</span>,<span class="built_in">al</span>                   <span class="comment">; 向主片发送</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">push</span> <span class="subst">%1</span>			 <span class="comment">; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便</span></span><br><span class="line">   <span class="keyword">call</span> [idt_table + <span class="subst">%1</span>*<span class="number">4</span>]       <span class="comment">; 调用idt_table中的C版本中断处理函数</span></span><br><span class="line">   <span class="keyword">jmp</span> intr_exit</span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line">   <span class="built_in">dd</span>    intr<span class="subst">%1</span>entry	 <span class="comment">; 存储各个中断入口程序的地址，形成intr_entry_table数组</span></span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span> intr_exit</span><br><span class="line"><span class="symbol">intr_exit:</span>	     </span><br><span class="line"><span class="comment">; 以下是恢复上下文环境</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">4</span>			   <span class="comment">; 跳过中断号</span></span><br><span class="line">   <span class="keyword">popad</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">gs</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">fs</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">4</span>			   <span class="comment">; 跳过error_code</span></span><br><span class="line">   <span class="keyword">iretd</span></span><br><span class="line"></span><br><span class="line">VECTOR <span class="number">0x00</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x01</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x02</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x03</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x04</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x05</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x06</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x07</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x08</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x09</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x0a</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x0b</span>,ERROR_CODE </span><br><span class="line">VECTOR <span class="number">0x0c</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x0d</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x0e</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x0f</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x10</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x11</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x12</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x13</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x14</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x15</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x16</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x17</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x18</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x19</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x1a</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x1b</span>,ERROR_CODE </span><br><span class="line">VECTOR <span class="number">0x1c</span>,<span class="meta">ZERO</span></span><br><span class="line">VECTOR <span class="number">0x1d</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x1e</span>,ERROR_CODE</span><br><span class="line">VECTOR <span class="number">0x1f</span>,<span class="meta">ZERO</span> </span><br><span class="line">VECTOR <span class="number">0x20</span>,<span class="meta">ZERO</span></span><br></pre></td></tr></table></figure>

<ul>
<li>28行call [idt_table + %1*4] ，idt_table是c语言版本的中断处理函数地址数组。中断处理线程的保护和恢复用汇编代码比较适合，因为保护和恢复都是特定的寄存器值，用c语言难以操作，但是中断处理程序具体做了什么事情可以用c语言，即用在进入中断前会汇编语言进行中断现场保护，进入中断后调用c语言版本的中断处理函数，最后用汇编语言进行中断现场恢复。</li>
<li>第9行定义中断处理程序数组intr_entry_table，该数组属于.data节，那么根据编译器同名节合并的原理，32行定义的每一个中断处理函数的入口地址都被安排在intr_entry_table里</li>
<li>中断处理程序数组intr_entry_table和c语言版本中断处理函数数组idt_table通过中断向量号一一对应</li>
</ul>
<h4 id="中断初始化"><a href="#中断初始化" class="headerlink" title="中断初始化"></a>中断初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIC_M_CTRL 0x20	       <span class="comment">// 这里用的可编程中断控制器是8259A,主片的控制端口是0x20</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIC_M_DATA 0x21	       <span class="comment">// 主片的数据端口是0x21</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIC_S_CTRL 0xa0	       <span class="comment">// 从片的控制端口是0xa0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIC_S_DATA 0xa1	       <span class="comment">// 从片的数据端口是0xa1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDT_DESC_CNT 0x21      <span class="comment">// 目前总共支持的中断数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断门描述符结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint16_t</span>    func_offset_low_word;</span><br><span class="line">   <span class="keyword">uint16_t</span>    selector;</span><br><span class="line">   <span class="keyword">uint8_t</span>     dcount;   <span class="comment">//此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑</span></span><br><span class="line">   <span class="keyword">uint8_t</span>     attribute;</span><br><span class="line">   <span class="keyword">uint16_t</span>    func_offset_high_word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数声明,非必须</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> <span class="title">idt</span>[<span class="title">IDT_DESC_CNT</span>];</span>   <span class="comment">// idt是中断描述符表,本质上就是个中断门描述符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* intr_name[IDT_DESC_CNT];		     <span class="comment">// 用于保存异常的名字</span></span><br><span class="line">intr_handler idt_table[IDT_DESC_CNT];	     <span class="comment">// 定义中断处理程序数组.在kernel.S中定义的intrXXentry只是中断处理程序的入口,最终调用的是ide_table中的处理程序</span></span><br><span class="line"><span class="keyword">extern</span> intr_handler intr_entry_table[IDT_DESC_CNT];	    <span class="comment">// 声明引用定义在kernel.S中的中断处理函数入口数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化可编程中断控制器8259A */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pic_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化主片 */</span></span><br><span class="line">   outb (PIC_M_CTRL, <span class="number">0x11</span>);   <span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">   outb (PIC_M_DATA, <span class="number">0x20</span>);   <span class="comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span></span><br><span class="line">   outb (PIC_M_DATA, <span class="number">0x04</span>);   <span class="comment">// ICW3: IR2接从片. </span></span><br><span class="line">   outb (PIC_M_DATA, <span class="number">0x01</span>);   <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化从片 */</span></span><br><span class="line">   outb (PIC_S_CTRL, <span class="number">0x11</span>);    <span class="comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span></span><br><span class="line">   outb (PIC_S_DATA, <span class="number">0x28</span>);    <span class="comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span></span><br><span class="line">   outb (PIC_S_DATA, <span class="number">0x02</span>);    <span class="comment">// ICW3: 设置从片连接到主片的IR2引脚</span></span><br><span class="line">   outb (PIC_S_DATA, <span class="number">0x01</span>);    <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打开主片上IR0,也就是目前只接受时钟产生的中断 */</span></span><br><span class="line">   outb (PIC_M_DATA, <span class="number">0xfe</span>);</span><br><span class="line">   outb (PIC_S_DATA, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">   put_str(<span class="string">"   pic_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建中断门描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span> </span>&#123; </span><br><span class="line">   p_gdesc-&gt;func_offset_low_word = (<span class="keyword">uint32_t</span>)function &amp; <span class="number">0x0000FFFF</span>;</span><br><span class="line">   p_gdesc-&gt;selector = SELECTOR_K_CODE;</span><br><span class="line">   p_gdesc-&gt;dcount = <span class="number">0</span>;</span><br><span class="line">   p_gdesc-&gt;attribute = attr;</span><br><span class="line">   p_gdesc-&gt;func_offset_high_word = ((<span class="keyword">uint32_t</span>)function &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化中断描述符表*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">idt_desc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;</span><br><span class="line">      make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); </span><br><span class="line">   &#125;</span><br><span class="line">   put_str(<span class="string">"   idt_desc_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通用的中断处理函数,一般用在异常出现时的处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">general_intr_handler</span><span class="params">(<span class="keyword">uint8_t</span> vec_nr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (vec_nr == <span class="number">0x27</span> || vec_nr == <span class="number">0x2f</span>) &#123;	<span class="comment">// 0x2f是从片8259A上的最后一个irq引脚，保留</span></span><br><span class="line">      <span class="keyword">return</span>;		<span class="comment">//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。</span></span><br><span class="line">   &#125;</span><br><span class="line">   put_str(<span class="string">"int vector: 0x"</span>);</span><br><span class="line">   put_int(vec_nr);</span><br><span class="line">   put_char(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完成一般中断处理函数注册及异常名称注册 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;			    <span class="comment">// 完成一般中断处理函数注册及异常名称注册</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,</span></span><br><span class="line"><span class="comment"> * 见kernel/kernel.S的call [idt_table + %1*4] */</span></span><br><span class="line">      idt_table[i] = general_intr_handler;		    <span class="comment">// 默认为general_intr_handler。</span></span><br><span class="line">							    <span class="comment">// 以后会由register_handler来注册具体处理函数。</span></span><br><span class="line">      intr_name[i] = <span class="string">"unknown"</span>;				    <span class="comment">// 先统一赋值为unknown </span></span><br><span class="line">   &#125;</span><br><span class="line">   intr_name[<span class="number">0</span>] = <span class="string">"#DE Divide Error"</span>;</span><br><span class="line">   intr_name[<span class="number">1</span>] = <span class="string">"#DB Debug Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">2</span>] = <span class="string">"NMI Interrupt"</span>;</span><br><span class="line">   intr_name[<span class="number">3</span>] = <span class="string">"#BP Breakpoint Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">4</span>] = <span class="string">"#OF Overflow Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">5</span>] = <span class="string">"#BR BOUND Range Exceeded Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">6</span>] = <span class="string">"#UD Invalid Opcode Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">7</span>] = <span class="string">"#NM Device Not Available Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">8</span>] = <span class="string">"#DF Double Fault Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">9</span>] = <span class="string">"Coprocessor Segment Overrun"</span>;</span><br><span class="line">   intr_name[<span class="number">10</span>] = <span class="string">"#TS Invalid TSS Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">11</span>] = <span class="string">"#NP Segment Not Present"</span>;</span><br><span class="line">   intr_name[<span class="number">12</span>] = <span class="string">"#SS Stack Fault Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">13</span>] = <span class="string">"#GP General Protection Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">14</span>] = <span class="string">"#PF Page-Fault Exception"</span>;</span><br><span class="line">   <span class="comment">// intr_name[15] 第15项是intel保留项，未使用</span></span><br><span class="line">   intr_name[<span class="number">16</span>] = <span class="string">"#MF x87 FPU Floating-Point Error"</span>;</span><br><span class="line">   intr_name[<span class="number">17</span>] = <span class="string">"#AC Alignment Check Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">18</span>] = <span class="string">"#MC Machine-Check Exception"</span>;</span><br><span class="line">   intr_name[<span class="number">19</span>] = <span class="string">"#XF SIMD Floating-Point Exception"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*完成有关中断的所有初始化工作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"idt_init start\n"</span>);</span><br><span class="line">   idt_desc_init();	   <span class="comment">// 初始化中断描述符表</span></span><br><span class="line">   exception_init();	   <span class="comment">// 异常名初始化并注册通常的中断处理函数</span></span><br><span class="line">   pic_init();		   <span class="comment">// 初始化8259A</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 加载idt */</span></span><br><span class="line">   <span class="keyword">uint64_t</span> idt_operand = ((<span class="keyword">sizeof</span>(idt) - <span class="number">1</span>) | ((<span class="keyword">uint64_t</span>)(<span class="keyword">uint32_t</span>)idt &lt;&lt; <span class="number">16</span>));</span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lidt %0"</span> : : <span class="string">"m"</span> (idt_operand))</span></span>;</span><br><span class="line">   put_str(<span class="string">"idt_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>idt_desc_init()中对数组的每一个元素进行初始化，即对每一个描述符调用make_idt_desc()进行初始化</li>
<li>make_idt_desc()设置描述符的选择子，便移地址，和各个属性位，最主要的就是将偏移地址指向了中断处理程序入口处，即intr_entry_table中对应的元素</li>
<li>exception_init()定义了从0~32个中断向量号的所有中断处理函数的初始化，起始就是初始化c语言版本的中断处理函数数组idt_table，也就是抛开中断现场保护和恢复，这个中断信号触发后具体要做哪些事情，只不过本次要做的事情只是打印中断向量号，将来若实现具体的中断，比如时钟中断，或者系统调用，只需要将idt_table这个数组中对应的元素重新赋值即可，非常方便</li>
<li>pic_init()初始化9259A，主要是设置中断向量号，级联，中断响应信号通知模式并打开时钟中断（只打开了时钟中断，其他外设中断都被屏IMR屏蔽）</li>
<li>第123行计算48位的中断描述符表缓存寄存器的值，存入64位的idt_operand，第124行使用扩展内联汇编通过lidt指令从idt_operand中提取低48位数据到IDTR寄存器中</li>
</ul>
<h4 id="时钟中断演示"><a href="#时钟中断演示" class="headerlink" title="时钟中断演示"></a>时钟中断演示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"sti"</span>)</span></span>;	     <span class="comment">// 为演示中断处理,在此临时开中断</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是上偏文章中我们编写的最简单的死循环内核，在init_all()中进行了中断初始化，并使用sti指令打开中断，然后便进入死循环</li>
<li>完成中断初始化并打开中断后，操作系统就不会再像上篇文章中演示的一样进入无限循环，而且什么事情也不做，而是每次时钟中断到来，都会调用时钟中断对应的中断处理函数，当然这里只是打印时钟中断的中断向量号，毕竟本篇文章只是通过时钟中断演示中断原理，具体时钟中断要做哪些事情会再以后进行修改并重新注册</li>
</ul>
<p><img src="/images/IMG_0065.JPG" alt="IMG_0065.JPG"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/保护模式之内核加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/12/保护模式之内核加载/" itemprop="url">保护模式之内核加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T10:00:30+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="生成内核"><a href="#生成内核" class="headerlink" title="生成内核"></a>生成内核</h3><h4 id="内核源码"><a href="#内核源码" class="headerlink" title="内核源码"></a>内核源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行</li>
<li>使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情</li>
<li>如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知的结果并最终崩溃</li>
</ul>
<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><h5 id="编译main-c得到main-o"><a href="#编译main-c得到main-o" class="headerlink" title="编译main.c得到main.o"></a>编译main.c得到main.o</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o kernel/main.o kernel/main.c</span><br></pre></td></tr></table></figure>

<h5 id="链接main-o得到kernel-bin"><a href="#链接main-o得到kernel-bin" class="headerlink" title="链接main.o得到kernel.bin"></a>链接main.o得到kernel.bin</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin</span><br></pre></td></tr></table></figure>

<ul>
<li>-Ttext 0xc0001500指定该程序的入口地址，这个信息会写入到kernel.bin的文件头中（关于文件头的作用稍后介绍）</li>
<li>-e main 指定起始符号名，代表指定源码中“main”这个符号作为入口符号=0xc0001500，gcc默认入口符号是<em>start而不是main，我们平时编写的程序中虽然没有</em>  _start符号，但是编译时会链接进很多运行库代码，其中肯定有 _start 这个符号，这里我们采用我们平时的习惯，手动指定main函数为入口符号</li>
</ul>
<h3 id="计算机启动过程总结"><a href="#计算机启动过程总结" class="headerlink" title="计算机启动过程总结"></a>计算机启动过程总结</h3><ul>
<li><p>加电，ROM中BIOS开始运行，BIOS将磁盘上MBR加载到BIOS和MRB双方约定的0x7c00处。约定方法：MBR使用vstart告诉汇编编译器编译的起始虚拟地址为0x7c00，然后BIOS将MBR从磁盘上拷贝到内存地址0x7c00处，然后跳转到0x7c00，MBR开始运行</p>
</li>
<li><p>MBR执行完成所有的工作后，将磁盘上的bootloader加载到MBR和bootloader约定好的0x900处，约定方法：bootloader使用vstart告诉汇编编译器编译的起始虚拟地址为0x900，然后MBR将bootloader从磁盘上拷贝到内存地址0x900处，然后跳转到0x900处，loader开始运行</p>
</li>
<li><p>BIOS到MBR，MBR到loader的启动过程很不灵活，调用方需要提前和被调用方约定调用地址，然后调用方将磁盘上的被调用方拷贝到内存中的调用地址处，然后跳转到调用地址处执行</p>
</li>
<li><p>内核是用c语言编写，c编译器编译成的ELF格式的二进制文件，这种文件格式由headr+body组成，headr是程序头信息，里面包含该可执行文件的起始地址，各个段，各个节的信息表</p>
</li>
<li><p>loader需要先将kernel.bin拷贝到内存的某处空闲位置，然后读取分析程序头信息，找到程序入口地址，各个段起始地址，将各个段拷贝到各自的起始起始地址后，跳转到程序的入口地址开始执行，这就是loader加载内核的过程，也是操作系统内核加载用户程序的过程，即分析ELF可执行文件的程序头，将各个段拷贝到文件头中指定的地址处，然后跳转到文件头中指定入口地址处开始执行</p>
</li>
</ul>
<h3 id="ELF格式的二级制文件"><a href="#ELF格式的二级制文件" class="headerlink" title="ELF格式的二级制文件"></a>ELF格式的二级制文件</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>​    在ELF规范中，待重定向文件,共享库文件，和可执行文件都叫做“目标文件”或者ELF文件</p>
<p><img src="/images/24.jpg" alt="24.jpg"></p>
<h4 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h4><p><img src="/images/25.jpg" alt="25.jpg"></p>
<h4 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h4><p><img src="/images/26.jpg" alt="26.jpg"></p>
<p>​    位于文件的开头处，一共16字节，也就是磁盘中二级制可执行文件的前16个字节是这样一个数据结构，下面详细介绍该结构体中重要属性的含义：</p>
<ul>
<li><p>e_ident[16]字节数组，用来表示elf字符信息，开头4字节固定不变，是elf文件的魔数，分别是0x7f，以及字符串“ELF”的asc码：0x45,0x4c，0x46，数组中其他字节见下表</p>
<p><img src="/images/27.jpg" alt="27.jpg"></p>
</li>
<li><p>e_type占2字节，指定elf目标文件的具体类型，各种值代表的文件类型见下表</p>
<p><img src="/images/28.jpg" alt="28.jpg"></p>
</li>
<li><p>e_machine占2字节描述elf目标文件的体系结构类型，就是说该文件只能在哪种硬件平台上运行，可取的值见下表</p>
<p><img src="/images/29.jpg" alt="29.jpg"></p>
</li>
<li><p>e_version 占4字节，用来表示版本信息</p>
</li>
<li><p>e_entry 占用4字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址，就是说加载完程序后跳转到哪个地址上开始执行该进程</p>
</li>
<li><p>e_phoff占4字节，用来指明程序头表（Programma header table）在文件内的字节偏移量</p>
</li>
<li><p>e_shoff占4字节，用来指明节头表（section header table）在文件内的字节偏移量</p>
</li>
<li><p>e_flages占4字节</p>
</li>
<li><p>e_phsize占用2字节，用来指明整个elf header的字节大小，值为16</p>
</li>
<li><p>e_phentsize占2字节，用来指明程序头表（Programma header table）中每个条目的字节大小，该条目的结构是struct Elf32_Phdr，稍后详细介绍</p>
</li>
<li><p>e_phnum占2字节，用来指明程序头表中条目的数量。就是段的个数</p>
</li>
<li><p>e_shentsize占2字节，用来指明节头表每个条目的字节大小</p>
</li>
<li><p>e_shnum占2字节，用来指明节头表中条目的数量，就是节的个数</p>
</li>
<li><p>e_shstrndx占2字节，用来指明string name table在节头表中的索引index</p>
</li>
</ul>
<h4 id="Program-header-table"><a href="#Program-header-table" class="headerlink" title="Program header table"></a>Program header table</h4><p>​    ELF header后面紧接着就是程序头表，所谓表就是数组，里面的元素都是一样的结构体，这个结构体就是struct Elf32_Phdr,下图是这个数组元素结构的定义</p>
<p><img src="/images/30.jpg" alt="30.jpg"></p>
<ul>
<li><p>p_type占4字节，用来指明该段的类型，p_type类型说明见下表</p>
<p><img src="/images/31.jpg" alt="31.jpg"></p>
</li>
<li><p>p_offset占用4字节，用来指明本地在文件内的起始偏移字节</p>
</li>
<li><p>p_vaddr占4字节，用来指明本段在内存中的起始虚拟地址，操作系统通过这个值来将该段拷贝到对应的内存中的虚拟地址处</p>
</li>
<li><p>p_filesz占4字节，用来指明本段在文件中的大小</p>
</li>
<li><p>p_memsz占4字节，用来指明本段在内存中的大小，一般都和p_filesz相等</p>
</li>
<li><p>p_flags占4字节，用来指明与本段相关的标志，此标志取值范围见下表</p>
<p><img src="/images/32.jpg" alt="32.jpg"></p>
</li>
<li><p>p_align占4字节，用来指明本段在文件和内存中的对齐方式，值为0或1表示不对齐</p>
</li>
</ul>
<h4 id="ELF文件实例分析"><a href="#ELF文件实例分析" class="headerlink" title="ELF文件实例分析"></a>ELF文件实例分析</h4><p><img src="/images/33.jpg" alt="33.jpg"></p>
<p>​    上图是xxd命令分析得到的文章开头得到的kernel.bin的二进制文件在磁盘上的字节分布，第一列是文件地址偏移量，中间是文件内容，右边是字节对应的符号，如果是不可见字符用“.”代替。浅下划线代表ELF headr的内容，粗下划线表示段头表，可以看到一共两个段，用“|”分隔开</p>
<p>根据对elf_header 和段头表中第一个段的分析后可以得到以下结论：</p>
<ol>
<li>程序入口地址e_entry的值是0xc0001500</li>
<li>程序第一段需要拷贝到虚拟地址p_vaddr 即0xc0001000处</li>
<li>程序的第一段的大小p_filesz是0x00000505</li>
</ol>
<p>从而可以知道加载器loader所要做的工作：</p>
<ol>
<li>将磁盘中的程序拷贝到一块空闲内存中</li>
<li>分析文件头信息，即elf_header,段头表，节头表，找到文件中第1个段的内容，即开头第0个字节到第0x505个字节，全部拷贝到虚拟地址0xc0001000处，同理找到第二个段的内容，也要拷贝到段头表中第二个元素中指定的虚拟地址处</li>
<li>将所有的段全部拷贝到段头表中各自指定虚拟地址处后，跳转到0xc0001500处开始执行内核代码，可以看到虽然整个程序体有几百字节，但是真正代码段中可执行的指令只有从0xc0001500开始到0xc0001505（0xc0001000+0x505）即5个字节的代码，经过验证main函数中的指令编译成二级制后的确只有5个字节。</li>
</ol>
<h3 id="将内核载入内存"><a href="#将内核载入内存" class="headerlink" title="将内核载入内存"></a>将内核载入内存</h3><h4 id="为什么是0xc0001500"><a href="#为什么是0xc0001500" class="headerlink" title="为什么是0xc0001500"></a>为什么是0xc0001500</h4><p><img src="/images/34.jpg" alt="34.jpg"></p>
<p>​    开启分页后0xc0001500在页表中对应的物理地址是0x00001500，loader在内存中的地址是0x900，而我们在loader中定义了GTD，所以内核代码不能覆盖loader，loader最大不超过2000个字节，0x900+2000=0x10d0，凑个整数，得到0x00001500，对应的虚拟地址为0xc0001500</p>
<h4 id="初始化内核的代码"><a href="#初始化内核的代码" class="headerlink" title="初始化内核的代码"></a>初始化内核的代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">; limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的空位(slot)</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span></span><br><span class="line">   <span class="comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span></span><br><span class="line">   <span class="comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span></span><br><span class="line">   total_mem_bytes <span class="built_in">dd</span> <span class="number">0</span>					 </span><br><span class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line"></span><br><span class="line">   <span class="comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span></span><br><span class="line">   ards_buf <span class="built_in">times</span> <span class="number">244</span> <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   ards_nr <span class="built_in">dw</span> <span class="number">0</span>		      <span class="comment">;用于记录ards结构体数量</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   准备进入保护模式   -------------------</span></span><br><span class="line"><span class="comment">;1 打开A20</span></span><br><span class="line"><span class="comment">;2 加载gdt</span></span><br><span class="line"><span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> <span class="built_in">dword</span> SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"><span class="symbol">.error_hlt:</span>		      <span class="comment">;出错则挂起</span></span><br><span class="line">   <span class="keyword">hlt</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------   加载kernel  ----------------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, KERNEL_START_SECTOR        <span class="comment">; kernel.bin所在的扇区号</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR       <span class="comment">; 从磁盘读出后，写入到ebx指定的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">200</span>			       <span class="comment">; 读入的扇区数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 创建页目录及页表并初始化页内存位图</span></span><br><span class="line">   <span class="keyword">call</span> setup_page</span><br><span class="line"></span><br><span class="line">   <span class="comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span></span><br><span class="line">   <span class="keyword">sgdt</span> [gdt_ptr]	      <span class="comment">; 存储到原来gdt所有的位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [gdt_ptr + <span class="number">2</span>]  </span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">0x18</span> + <span class="number">4</span>], <span class="number">0xc0000000</span>      <span class="comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span></span><br><span class="line">					      <span class="comment">;段描述符的高4字节的最高位是段基址的31~24位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">dword</span> [gdt_ptr + <span class="number">2</span>], <span class="number">0xc0000000</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">0xc0000000</span>        <span class="comment">; 将栈指针同样映射到内核地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr3</span>, eaxx</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;在开启分页后,用gdt新的地址重新加载</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]             <span class="comment">; 重新加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span></span><br><span class="line"><span class="comment">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span></span><br><span class="line">   <span class="keyword">jmp</span> SELECTOR_CODE:enter_kernel	  <span class="comment">;强制刷新流水线,更新gdt</span></span><br><span class="line"><span class="symbol">enter_kernel:</span>    </span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">   <span class="keyword">call</span> kernel_init</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="number">0xc009f000</span></span><br><span class="line">   <span class="keyword">jmp</span> KERNEL_ENTRY_POINT                 <span class="comment">; 用地址0x1500访问测试，结果ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span></span><br><span class="line"><span class="symbol">kernel_init:</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		<span class="comment">;ebx记录程序头表地址</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>		<span class="comment">;cx记录程序头表中的program header数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		<span class="comment">;dx 记录program header尺寸,即e_phentsize</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">42</span>]	  <span class="comment">; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">28</span>]   <span class="comment">; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span></span><br><span class="line">					  <span class="comment">; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">44</span>]    <span class="comment">; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span></span><br><span class="line"><span class="symbol">.each_segment:</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">byte</span> [<span class="built_in">ebx</span> + <span class="number">0</span>], PT_NULL		  <span class="comment">; 若p_type等于 PT_NULL,说明此program header未使用。</span></span><br><span class="line">   <span class="keyword">je</span> .PTNULL</span><br><span class="line"></span><br><span class="line">   <span class="comment">;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">16</span>]		  <span class="comment">; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + <span class="number">4</span>]			  <span class="comment">; 距程序头偏移量为4字节的位置是p_offset</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, KERNEL_BIN_BASE_ADDR	  <span class="comment">; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">eax</span>				  <span class="comment">; 压入函数memcpy的第二个参数:源地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">8</span>]			  <span class="comment">; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span></span><br><span class="line">   <span class="keyword">call</span> mem_cpy				  <span class="comment">; 调用mem_cpy完成段复制</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">12</span>				  <span class="comment">; 清理栈中压入的三个参数</span></span><br><span class="line"><span class="symbol">.PTNULL:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>				  <span class="comment">; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span></span><br><span class="line">   <span class="keyword">loop</span> .each_segment</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span></span><br><span class="line"><span class="comment">;输入:栈中三个参数(dst,src,size)</span></span><br><span class="line"><span class="comment">;输出:无</span></span><br><span class="line"><span class="comment">;---------------------------------------------------------</span></span><br><span class="line"><span class="symbol">mem_cpy:</span>		      </span><br><span class="line">   <span class="keyword">cld</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span>		   <span class="comment">; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]	   <span class="comment">; dst</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + <span class="number">12</span>]	   <span class="comment">; src</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">16</span>]	   <span class="comment">; size</span></span><br><span class="line">   <span class="keyword">rep</span> <span class="keyword">movsb</span>		   <span class="comment">; 逐字节拷贝</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;恢复环境</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ecx</span>		</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性RW和P位为1,US为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">			   <span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_32:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">							 <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">							 <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">							 <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	   <span class="comment">; 备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		   <span class="comment">; 备份扇区数到di</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          x</span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span>		   <span class="comment">;测试0x1f7端口(status寄存器)的的BSY位</span></span><br><span class="line">      <span class="comment">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好,继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span>	   <span class="comment">;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span></span><br><span class="line">			   <span class="comment">;在此先用这种方法,在后面内容会用到insw和outsw等</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span>	   <span class="comment">;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>		</span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">ebx</span>], axx</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">			  <span class="comment">; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span></span><br><span class="line">			  <span class="comment">; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span></span><br><span class="line">			  <span class="comment">; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span></span><br><span class="line">			  <span class="comment">; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span></span><br><span class="line">			  <span class="comment">; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span></span><br><span class="line">			  <span class="comment">; 故程序出会错,不知道会跑到哪里去。</span></span><br><span class="line">			  <span class="comment">; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span></span><br><span class="line">			  <span class="comment">; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span></span><br><span class="line">			  <span class="comment">; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span></span><br><span class="line">			  <span class="comment">; 也会认为要执行的指令是32位.</span></span><br><span class="line">			  <span class="comment">; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span></span><br><span class="line">			  <span class="comment">; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x6x7，</span></span><br><span class="line">			  <span class="comment">; 临时改变当前cpu模式到另外的模式下.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h4 id="内核在低端1MB中的内存布局"><a href="#内核在低端1MB中的内存布局" class="headerlink" title="内核在低端1MB中的内存布局"></a>内核在低端1MB中的内存布局</h4><p><img src="/images/35.jpg" alt="35.jpg"></p>
<ul>
<li><p>0x900处开始是loader，其中loader的开始处是全局描述符表GTD，不能被覆盖，所以内核代码要安置到远离0x900较远的0x1000处（但是从0x1500处开始执行，0x1000到0x1500之间是elf header等内容）</p>
</li>
<li><p>可以看到MBR在0x7c00处，在内核之上，将来内核增大时，肯定会覆盖MBR的代码，不过这无关紧要，因为进入loader后MBR的使命已经完成，被覆盖也无关紧要</p>
</li>
<li><p>内核加载完成后，内核栈指针被设置成了0x9f000，即我们的内核代码在0x00001000到0x0009f000之间</p>
<p><img src="/images/34.jpg" alt="34.jpg"></p>
</li>
<li><p>从上图可以看出，低端1MB可用空间中最高地址是0x9FBFF，那么按理说内核栈指针可以设置到0x9fc00，而我们却选择了0x9f000，乍一看是浪费了0xc00字节的空间，其实不然，选则0x9f000为内核栈指针是因为每个PCB都是自然页，也就是4KB对齐，即类似0x000-0xfff这样，而不是类似0x333-0x1332这样的页内存块，而将来我们会在内核最高处设置内核进程的PCB，所有选择4k整数倍的地址0x9f000</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/11/保护模式之虚拟地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/11/保护模式之虚拟地址/" itemprop="url">保护模式之虚拟地址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T14:32:26+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><h4 id="内存分段机制下的地址访问"><a href="#内存分段机制下的地址访问" class="headerlink" title="内存分段机制下的地址访问"></a>内存分段机制下的地址访问</h4><p><img src="/images/15.jpg" alt="15.jpg"></p>
<h4 id="分段模式存在的问题"><a href="#分段模式存在的问题" class="headerlink" title="分段模式存在的问题"></a>分段模式存在的问题</h4><p><img src="/images/14.jpg" alt="14.jpg"></p>
<p>​    假设内存中同时存在进程A,B,C,他们分别占用10M，20M，30M内存，空余内存15M，如果进程B运行结束，空余20M内存，磁盘中的程序D需要占用20M+3KB的内存，那么这个时候程序D将无法立即被操作系统载入内存运行。如果要运行D程序，有两种解决办法：</p>
<ol>
<li>等待进程A或者进程C运行结束，空出他们所占用的内存</li>
<li>将进程A的A3段或者进程C的C1段换出到磁盘</li>
</ol>
<p>第一种方案需要进程D无期限的等待别的进程结束，这必然无法接受；第二种方案会导致频繁的磁盘IO，但至少是一种可行的解决方案。但是如果进程D需要的内存容量超过系统的所有内存容量（包括已经使用的），那么即使将所有其他进程的内存段换出到磁盘，进程D也无法运行。</p>
<h4 id="如何从根本上解决分段模式问题"><a href="#如何从根本上解决分段模式问题" class="headerlink" title="如何从根本上解决分段模式问题"></a>如何从根本上解决分段模式问题</h4><p>​    CPU认为编译器编译出来的线性地址就是物理地址，线性地址是连续的，所以物理地址也必须要连续才行。换句话说，如果线性地址连续，而物理地址可以不连续，就可以解决上述的所有问题。所有必须解除线性地址于物理地址的相等关系，让线性地址通过某种映射可以对应到物理地址，没错，这种映射关系就是分页模式中的页表</p>
<h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><h4 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h4><p><img src="/images/16.jpg" alt="16.jpg"></p>
<ul>
<li>4GB线性地址空间是指位于磁盘上的被编译器编排好的二进制程序中的线性地址</li>
<li>4GB虚拟地址空间是指每个进程的虚拟地址空间，每个进程都有自己的虚拟地址池，池中也是一页一页的内存块，每个进程也都有自己的虚拟地址位图来管理这些虚拟页</li>
<li>4GB物理地址空间就是只物理内存地址，也是通过物理内存池和位图以页为单位来管理</li>
</ul>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><p>​    现代操作系统都是多级页表，32位操作系统中一般是两级页表，本系列研究32位操作系统，与64位的4级页表原理上是一样的</p>
<p><img src="/images/18.jpg" alt="18.jpg"></p>
<ul>
<li>4GB线性地址空间最多有4GB/4KB=1M个页，将1M个页平均放置到1K个页表中,则每个页表有1M/1K=1K个页表项目，页表项4字节大小，用1K个页表项，则页表的大小为4KB，正好也是一个页的大小</li>
<li>一张页表大小4KB，表中都是页表项PTE，每个页表项4字节大小，共有1024个页表项，每个页表项中存储物理页的实际物理地址和属性信息，即一张页表存储了1024个物理页的实际物理地址和属性信息，能够映射4KB*1024=4MB大小的物理内存。</li>
<li>二级页表一共1M个页表，一个页表映射4MB，则最大能映射4MB*1M=4GB大小的内存，也是32位系统的最大地址范围</li>
<li>由页目录表存储页表的物理地址和属性信息，页目录表一个4KB大小，表中都是4字节大小的页目录，这样可以存储1KB=1024个页表的实际物理地址和属性信息</li>
<li>页目录表和页表是用于管理内存的数据结构，也要占用实际的物理内存，所有页目录表和页表所占用的物理页，同样混迹于物理内存中，如上图所示。</li>
</ul>
<h4 id="虚拟地址到物理地址转换"><a href="#虚拟地址到物理地址转换" class="headerlink" title="虚拟地址到物理地址转换"></a>虚拟地址到物理地址转换</h4><h5 id="转换原理"><a href="#转换原理" class="headerlink" title="转换原理"></a>转换原理</h5><ul>
<li>32位虚拟地址拆分成高10位，中间10位，低12位</li>
<li>高10位作为页目录表的索引，用于在页目录表中定位一个页目录项目PDE，4字节的PDE中有页表物理地址，也就是定位到了某个页表（索引需要乘4）</li>
<li>中间10位作为页表的索引，用于在上述已经定位到的页表中去定位一个页表项目PTE，4字节的PTE中有物理页的物理地址，也就是定位到了某个物理页（索引需要乘4）</li>
<li>低12位作为页内偏移量用于在已经定位到的物理页中寻址（12位正好是1MB，可以逐字节索引）</li>
</ul>
<h5 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h5><ol>
<li>虚拟地址高10位乘4，作为页目录表内的偏移地址，加上页目录表的物理地址（存储中cr3寄存器），所得的和就是页目录项的物理地址，读取该页目录项目，从中获取页表的物理地址</li>
<li>虚拟地址中间10位乘4，作为页表内的偏移量，加上第1步中得到的页表物理地址，所得的和，便是页表项的物理地址，读取该页表项，从中获取到分配的物理页地址</li>
<li>虚拟地址的低12位，作为第2步中得到的物理页的偏移量，即虚拟地址低12位加该物理页的物理地址，所得的和便是最终转换的物理地址</li>
</ol>
<p>这些转换过程由处理器页部件MMU自动完成，下图是以虚拟地址0x1234567为例，给出转换过程</p>
<p><img src="/images/19.jpg" alt="19.jpg"></p>
<h4 id="页目录项和页表项详情"><a href="#页目录项和页表项详情" class="headerlink" title="页目录项和页表项详情"></a>页目录项和页表项详情</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>PDE和PTE除了第7位外，基本相同，第12到第31位共20位表示页表或者物理页的物理地址，因为页表和页目录表的大小都是4KB，而且在内存中的分布都是按照4KB对齐，所有每个页表包括页目录表的物理地址的第12位都是0，所以只要20位足以。</li>
<li>PDE和PTE的第0到第11位都是属性位，记录该页的各种属性</li>
</ul>
<p><img src="/images/20.jpg" alt="20.jpg"></p>
<h5 id="重要属性位"><a href="#重要属性位" class="headerlink" title="重要属性位"></a>重要属性位</h5><ul>
<li>P，Present，P位为1表示该页存在于物理内存中，为0表示该页不存在物理内存中</li>
<li>A，Accessed ，访问位，为1表示被CPU访问过。可以用来记录某一内存页的使用频率，操作系统定期将该位清0，统计一段时间内变成1的次数，从而内存不足时，可以将使用频率较低的页面换出到外存，同时将P为置0，下次访问该页将引起缺页异常，中断处理程序将硬盘上的页再次换入，同时再将P位置1</li>
<li>RW 读写位，1表示可读可写，0表示可读不可写</li>
<li>US 普通用户/超级用户位，为1表示处于User级，任意特权级（0,1,2,3）的程序都可以访问该页，为0表示只允许0,1,2特权级程序访问该页</li>
</ul>
<h3 id="通过页表共享内核地址空间"><a href="#通过页表共享内核地址空间" class="headerlink" title="通过页表共享内核地址空间"></a>通过页表共享内核地址空间</h3><p>​    4GB虚拟地址空间分成2部分，3-4GB地址空间属于内核地址空间，0-3GB属于用户进程地址空间，所有用户进行要共享3-4GB的内核地址空间，这个“共享”的理解如下：</p>
<ul>
<li>操作系统属于内核代码，用户进行调用的内核代码都是在同一份物理内存中，比如中断处理程序，物理内存中仅此一份，所有用户进程都可以调用</li>
<li>用户进程A通过系统调用进入0特权级，并修改或者申请了内核地址空间一块内存，比如申请了一块内存，这块虚拟内存的地址为0xC00090000，当然0xC0009000肯定映射到了某块物理内存，假设该物理内存的首地址为0x12340000。那么0xC0009000这个虚拟地址对应的物理内存块0x12340000，对于其他用户进程也是可以访问的（但要通过系统调用先进入内核态），也就是说，如果用户进程B进入内核态后，直接访问0xC0009000时，操作系统并不会抛出类似”野指针”的这种异常错误，而且用户进程B在内核态访问0xC0009000时，最后访问到的也是同一片物理内存0x12340000，进程间通信中的共享内存方式就是上述的例子，某个进程在内核空间通过系统调用申请一块内存，其他进程同样可以访问到这块内存，虽然是通过文件描述符，但是这个文件描述必然在内核代码中被转换成这块位于内核空间的虚拟内存地址，所有进程都可以通过这个虚拟内存地址去访问这块内存</li>
</ul>
<p>如何通过页表做到以上所说的“共享”呢？其实就是让用户进程3GB-4GB的虚拟地址空间都指向同一个操作系统，也就是所有进程的虚拟地址3GB-4GB本质上都是指向同一片物理页地址。具体实现的方法就是保证所有用户进程虚拟地址空间3GB-4GB对应的页表项中所记录的物理页地址</p>
<h3 id="启用分页"><a href="#启用分页" class="headerlink" title="启用分页"></a>启用分页</h3><h4 id="页目录表和页表的布局"><a href="#页目录表和页表的布局" class="headerlink" title="页目录表和页表的布局"></a>页目录表和页表的布局</h4><p><img src="/images/21.jpg" alt="21.jpg"></p>
<p>​    页目录表位于物理地址0x100000处，即内核1MB以上的最开始处，页表紧挨着页目录表，即第一张页表的物理地址是0x101000，如下图：</p>
<p><img src="/images/22.jpg" alt="22.jpg"></p>
<h4 id="创建页目录表和页表"><a href="#创建页目录表和页表" class="headerlink" title="创建页目录表和页表"></a>创建页目录表和页表</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性US,RW和P位都为1</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h4 id="用虚拟地址访问页表"><a href="#用虚拟地址访问页表" class="headerlink" title="用虚拟地址访问页表"></a>用虚拟地址访问页表</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>​    页表是会动态增加或者删减的，所有在操作系统对内存进行申请或者释放时，会需要在页表中添加页表项目或者删除页表项（使用属性位逻辑删除），所以必须实现这样一个功能：任意给处一个虚拟地址A，我通过某种算法处理一下这个虚拟地址B，然后将这个虚拟地址B提交给CPU地址总线，经过页部件MMU转换后，CPU最终定位到这个虚拟地址A所对应的页目录项的实现物理地址，也可以定位到这个虚拟地址A所对应的页表项的实际物理地址。</p>
<h5 id="页目录表设计"><a href="#页目录表设计" class="headerlink" title="页目录表设计"></a>页目录表设计</h5><ul>
<li>页目录表第768页目录项中的物理地址指向第一张页表，代表0xC0000000～0xC0010000这1MB内存映射到低端0x00000000~0x00010000这1MB</li>
<li>页目录表的第0个页目录项的物理地址也指向第一张页表，原因是兼容分段机制</li>
<li>页目录的最后一下即第1023个页目录中的物理地址指向页目录表本身的物理地址，即0x00010000</li>
</ul>
<h5 id="获取能够访问页表项的虚拟地址算法"><a href="#获取能够访问页表项的虚拟地址算法" class="headerlink" title="获取能够访问页表项的虚拟地址算法"></a>获取能够访问页表项的虚拟地址算法</h5><p>​    假设有虚拟地址A，那么：</p>
<ul>
<li>页目录表的物理地址：使用虚拟地址B：0xFFFFF000，就可以访问到页目录表本身的地址</li>
<li>可以访问到A对应页目录项的虚拟地址B：0xFFFFFXXX，其中XXX为虚拟地址A的高10位</li>
<li>可以访问到A对应的页表项的虚拟地址B：高10位都为1，即0x3FF，中间10位是虚拟地址A的高10位，低12为虚拟地址A的中间10乘4</li>
</ul>
<h3 id="TLB简介"><a href="#TLB简介" class="headerlink" title="TLB简介"></a>TLB简介</h3><p>​    通过虚拟地址得到物理地址的过程比较复杂，要查页表，做乘法，页表本身处于内存中，内存对于CPU来说是低俗设备，如果每次寻址都要做一遍转换的话，效率太低，所以处理器准备一种高速缓存，专门用来存放虚拟地址页框与物理地址页框的映射关系，这个高速缓存就是TLB，俗称“快表”</p>
<p><img src="/images/23.jpg" alt="23.jpg"></p>
<p>​    每次向处理器提交虚拟地址时，会使用该地址的高20位（低12位无意义）去查找对应的物理页地址的高20位，如果缓存命中，就不会去走虚拟地址到物理地址的漫长转换，如果没命中，则会去查页表最后获得物理页的物理地址，然后更新TLB</p>
<p>​    TLB容量很小，只有当前任务的的部分页表，而且只有P位为1的页表项才有资格在TLB中，如果TLB装满了，需要将最少使用频率的页的条目换出</p>
<p>​    进程间切换相对于线程间切换的一个劣势就是，进程间切换会导致TLB中的条目全部失效，缓存全部无法命中</p>
<p>​    TLB的更新是由操作系统来更新的，因为CPU不知道何时修改或者更新了页表，只有操作系统知道何时更改了页表，所以只能由操作系统负载去更新，更新TLB的指令有两种，一种是重新加载cr3寄存器，这将导致整个TLB失效，另一种是使用invlp m,m表示要更新的虚拟内存地址</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/golang默认打开RESUSEADDR选项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/golang默认打开RESUSEADDR选项/" itemprop="url">golang默认打开RESUSEADDR选项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T12:41:37+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="REUSEADDR"><a href="#REUSEADDR" class="headerlink" title="REUSEADDR"></a>REUSEADDR</h3><ul>
<li><p>c语言中的socket选项，默认是0即不打开</p>
</li>
<li><p>主要用于服务端如果在运行过程中出现主动关闭情况时（一般情况都是被动关闭），服务端的在本机的监听端口将处于TIME_WAIT状态，此时如果重启服务器的话将出现bind: address already in use错误，必须等2MSL的时间后，才能重启成功</p>
</li>
<li><p>打开REUSEADDR选项后，即使监听端口处于TIME_WAIT状态，依然可以正常bind并启动成功</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<h3 id="echoserver主动关闭连接实验"><a href="#echoserver主动关闭连接实验" class="headerlink" title="echoserver主动关闭连接实验"></a>echoserver主动关闭连接实验</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	host <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">""</span>, <span class="string">"host"</span>)</span><br><span class="line">	flag.StringVar(&amp;port, <span class="string">"p"</span>, <span class="string">"3333"</span>, <span class="string">"port"</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">var</span> l *net.TCPListener</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line"></span><br><span class="line">	tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, host+<span class="string">":"</span>+port)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	l, err = net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err = l.Accept()</span><br><span class="line">		fmt.Printf(<span class="string">"client:%s connect\n"</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleClient(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> readstr <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		n, err = conn.Read(buf)</span><br><span class="line">		conn.Close()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"client:%s closed\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			readstr = strings.ToUpper(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">			_, err = conn.Write([]<span class="keyword">byte</span>(readstr))</span><br><span class="line">			checkError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"Fatal error:%s\n"</span>, err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    echoserver读到客户端数据时，变直接调用conn.close()主动关闭（为了模拟服务端监听端口出现TIME_WAIT）echoserver以本地网卡10.129.21.36，并监听端口5000 启动，使用nc 127.0.0.1 8000 进行连接，端口占用情况如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000   0.0.0.0:*         LISTEN      30236/./echoserver  </span><br><span class="line">tcp     0       10.129.21.36:5000   127.0.0.1:8000    ESTABLISHED 30236/./echoserver  </span><br><span class="line">tcp     0       127.0.0.1:8000      10.129.21.36:5000 ESTABLISHED 30254/./echoclient</span><br></pre></td></tr></table></figure>

<p>​    在nc中输入任意字符串并回车后,echoserver会立即主动关闭连接并退出进程，监听端口5000出现TIME_WAIT状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000   127.0.0.1:8000    TIME_WAIT   -</span><br></pre></td></tr></table></figure>

<p>​    此时如果echoserver进程重新以5000监听端口启动，不会报错，启动成功，并且用netstat查看xuanx10.129.21.36这张网卡的5000端口同时出现Listen 和TIME_WAIT状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000    0.0.0.0:*         LISTEN     31281/./echoserver  </span><br><span class="line">tcp     0       10.129.21.36:5000    127.0.0.1:8000    TIME_WAIT  -</span><br></pre></td></tr></table></figure>

<p>​    可以看到新的echoserver进程（pid为31281，之前的pid为30236）正常启动，并监听在5000端口，同时之前的echoserver进程的127.0.0.1:8000-&gt;10.129.21.36:5000的连接由于服务端主动关闭连接动作而导致10.129.21.36的5000端口变成TIME_WAIT状态，但是新的echoserver进行依然能使用10.129.21.36:5000正常绑定和监听</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    从实验结果来看，golang的net包在创建server时，默认启用REUSEADDR这个socket选项</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/golang实现echoserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/golang实现echoserver/" itemprop="url">golang实现echoserver</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T09:56:40+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="echoserver"><a href="#echoserver" class="headerlink" title="echoserver"></a>echoserver</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	host <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">""</span>, <span class="string">"host"</span>)</span><br><span class="line">	flag.StringVar(&amp;port, <span class="string">"p"</span>, <span class="string">"3333"</span>, <span class="string">"port"</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">var</span> l *net.TCPListener</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line"></span><br><span class="line">	tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, host+<span class="string">":"</span>+port)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	l, err = net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err = l.Accept()</span><br><span class="line">		fmt.Printf(<span class="string">"client:%s connect\n"</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleClient(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> readstr <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		n, err = conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"client:%s closed\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			readstr = strings.ToUpper(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">			_, err = conn.Write([]<span class="keyword">byte</span>(readstr))</span><br><span class="line">			checkError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"Fatal error:%s\n"</span>, err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接受客户端连接后起一个协程处理客户端发来的数据</li>
<li>对客户端发来的英文字符串转大写后回写客户端</li>
<li>服务端执行被动关闭，当客户端发起主动关闭时，服务端将读到EOF，并执行被动关闭</li>
</ul>
<h3 id="echoclient"><a href="#echoclient" class="headerlink" title="echoclient"></a>echoclient</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	remoteAddr <span class="keyword">string</span></span><br><span class="line">	remotePort <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">	flag.StringVar(&amp;remoteAddr,<span class="string">"h"</span>,<span class="string">"127.0.0.1"</span>,<span class="string">"remoteAddr"</span>)</span><br><span class="line">	flag.StringVar(&amp;remotePort,<span class="string">"p"</span>,<span class="string">"3333"</span>,<span class="string">"remotePort"</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> tcpAddr *net.TCPAddr</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line">	<span class="keyword">var</span> buf =<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> temp []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> inputReader=bufio.NewReader(os.Stdin)</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">	tcpAddr,err=net.ResolveTCPAddr(<span class="string">"tcp"</span>,remoteAddr+<span class="string">":"</span>+remotePort)</span><br><span class="line">	checkError(err)</span><br><span class="line">	conn,err=net.DialTCP(<span class="string">"tcp"</span>,<span class="literal">nil</span>,tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		temp,err=inputReader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">		checkError(err)</span><br><span class="line">		_,err=conn.Write(temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr,<span class="string">"Fatal error:%s\n"</span>,err.Error())</span><br><span class="line">			conn.Close()</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n,err=conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">"server closed"</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr,<span class="string">"Fatal error:%s\n"</span>,err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端读入标准输入的数据发送服务端，接受服务端回写的数据到标准输出</li>
<li>如果服务端退出，客户端将读到EOF，客户端同时关闭连接并退出</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个最简单的使用golang实现的c/s模型echoserver，虽然看起来简单，但其实只是golang对c语言中epoll多路复用模型的封装</li>
<li>今后的网络编程的学习中将以这个echoserver为例，对场景的问题场景进行复现和分析</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/TIMEWAIT和端口复用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/TIMEWAIT和端口复用/" itemprop="url">TIMEWAIT和端口复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T16:23:08+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    TIME_WAIT和端口复用这两个概念既有区别又有联系，很多人认为端口复用是用来专门解决TIME_WAIT，其实这是一种错误的认知，错就错在“专门”上，端口复用的主要解决的是服务器进程快速重启、单进程accept调用的并发瓶颈和“惊群”效应，本文将详细介绍TIME_WAIT状态存在的必要性、原因以及减少TIME_WAIT数量的方法，然后介绍实现端口复用的两个socket选项：REFUSEADDR和REFUSEPORT,用具体的示例来说明这两个选项的最常用的使用场景。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><h4 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h4><p><img src="/images/network/8.png" alt="network/8.png">    </p>
<p>主动发起关闭动作的一方在收到对端发来的FIN报文并发送ACK后，进入TIME_WIAT状态，这个状态持续的时间是固定的2MSL，大约120s</p>
<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><ul>
<li>如果没有TIME_WAIT，主动关闭方调用close，向对端发送FIN后直接进入close状态，那么这条tcp连接的上下文将被立即释放，此时如果对端也调用close，发送FIN报文后，由于在主动方这条连接已经不存在，主动方只能发送一个RST复位报文，那么被动方就会出现错误</li>
<li>持续2MSL这么长时间的目的是为了让主动关闭放的最后一个ACK能让被动方接受，同时可以让“迷走报文”能够有足够长的时间游荡在网络中，从而被网络丢弃，否则这些”迷走报文”将对新建立的连接产生影响</li>
</ul>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul>
<li>socket=(本地ip，本地port，远端ip，远端port），当进程作为一个客户端对一个已知ip和port的远端服务端发起连接时，在这个连接对应的socket中，本地ip固定，远端ip和远端port都已固定，只有16位的本地port是操作系统临时分配的，所有操作系统能允许对同一个远端服务器进程同时建立的连接数=2的16次方，即65535，而操作系统前1024个端口号不允许用户进程占用，所以真正可以使用端口号的范围为1024~65535</li>
<li>内存资源占用，但几乎可以忽略不计</li>
<li>端口资源占用，比如nginx在做反向代理时，即是客户端的也是服务端，当作为客户端反向代理到上游服务器建立tcp连接时，如果nginx主动关闭对上游服务的连接，此时这个连接状态就会变成TIME_WAIT,在反向代理是有内核分配的端口将不能被使用，当与上游服务器建立大量的tcp短连接时，nginx所在的机器就会出现大量的TIME_WAIT,直到消耗尽系统的端口数量，此时服务就会出现时而能访问，时而又不能访问的诡异现象优化</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>​    调整内核参数，设置net.ipv4.tcp_tw_reuse=1，调整完后，nginx向上游服务器发起断开连接的请求后，只需过1s，这个断开的处于TIME_WAIT的状态的端口就可以再次被nginx用来向上游服务器用来建立连接</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    从以上叙述看来，TIME_WAIT和端口复用没有太大的关联，解决TIME_WAIT数量过多的最有效方法也只是适用进程作为客户端对外发起大量连接，而端口复用于TIME_WAIT唯一的联系就是，某一个端口处在TIME_WAIT状态，而这个端口又是某个服务进场启动时候的监听端口时，开启端口复用选项可以让服务进程立即启动，而不必等待2MSL的时间，当然这只是端口复用的一个使用场景，端口复用还有另一个使用场景就是让多个进程（通常是子进程）同时监听相同端口，当有客户端建立连接的请求过来时，由内核通过某种负载均衡策略将连接转移到不同进程上，目的是解决有大量客户端同时建立连接时，单进程accept调用的瓶颈（对正在建立连接的请求有数量限制，即listen函数的第二个参数，默认是1024，表示同时想服务进程进行三次握手动作的客户端的最大数量，注意是仅仅指正在进行三次握手动作的客户端数量，不包括建立好连接的客户端数量）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/Http协议核心知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Http协议核心知识/" itemprop="url">Http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T09:29:35+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络协议/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ul>
<li>灵活可扩展 </li>
<li>可靠传输</li>
<li>请求-应答通信模型</li>
<li>无状态</li>
</ul>
<h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul>
<li>明文不安全</li>
<li>队头阻塞性能差</li>
</ul>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><h4 id="数据类型、编码和语言"><a href="#数据类型、编码和语言" class="headerlink" title="数据类型、编码和语言"></a>数据类型、编码和语言</h4><ul>
<li><p>Accept客户端告诉服务器我这次请求能支持的响应数据类型,例如Accept:text/html,application/xml,image/webp,image</p>
</li>
<li><p>Content-Type服务器通知客户端段返回的数据类型，例如Content-Type: text/html</p>
</li>
<li><p>Accept-Encoding客户端通知服务器支持的压缩格式，例如Accept-Encoding: gzip, deflate, br</p>
</li>
<li><p>Content-Encoding服务器通知客户端所使用的压缩算法，例如Content-Encoding: gzip</p>
</li>
<li><p>Accept-Language客户端告诉服务器可以理解的自然语言，例如Accept-Language: zh-CN, zh, en</p>
</li>
<li><p>Content-Language服务端告诉客户端返回数据的实际语言,例如Content-Language: zh-CN</p>
</li>
<li><p>Accept-Charset客户端通知服务端我支持的字符集，例如Accept-Charset: gbk, utf-8，但是服务端返回的字符集类型存在于Content-Type中，例如Content-Type: text/html; charset=utf-8</p>
</li>
<li><p>客户端可以使用权重q=value来告诉服务端客户端的“喜好”，q的范围为0.01~1，默认是1。例如Accept: text/html,application/xml;q=0.9,<em>/</em>;q=0.8（最喜欢权重为1的html，其次是权重为0.9的xml，最后是权重是0.8的任意数据）</p>
</li>
</ul>
<h4 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h4><ul>
<li><p>分块传输常用于大文件的流式传输，可以实现变传输变渲染，提高用户体验</p>
</li>
<li><p>Transfer-Encoding: chunked 服务端告诉客户端响应数据是分块传输的，你需要按照我们定好的分块传输格式提取每个分块的内容，然后组合在一起，过程中客户端与服务器的连接仍然维持不会断开。</p>
</li>
<li><p>每个分块数据的格式：分块长度+分块数据，每个部分都用CRLF来分隔，客户端根据这个分隔符和分块长度正确提取每个分块的数据，并使用一个分块长度为0的”结束分块“来告知客户端所有分块传输完毕</p>
</li>
<li><p><img src="/images/network/1.png" alt="network/1.png"></p>
</li>
</ul>
<ul>
<li>Transfer-Encoding: chunked 和Content-Length不能同时使用，Content-Length表示一次完成的请求中传输的所有内容长度；而分块传输的所有分块都只是一次=请求中未完成的一部分，具体现象见下图</li>
<li><img src="/images/network/2.gif" alt="network/2.gif"></li>
</ul>
<h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><ul>
<li><p>范围请求常用于视频播放中的进度条拖到，跳过片头等功能</p>
</li>
<li><p>Range 客户端使用Range:bytes=0-50 通知服务端只返回响应的0~50个字节，可以指定多个范围，用”,”分隔</p>
</li>
<li><p>服务端接受到客户端的Range请求后要做以下3件事情：</p>
<ol>
<li>检查客户端要求的范围是否合法，如果超出响应数据的范围，返回416错误码</li>
<li>范围正确，根据请求头Range头计算偏移量，截取对应数据，并返回206状态吗</li>
<li>添加响应头Content-Range头，例如Content-Range:bytes 0-10/100，表示这次请求按照你的要求返回了0-10字节的内容，整个文件的内容长度是100字节</li>
</ol>
</li>
<li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.test.com</span><br><span class="line"><span class="attribute">Range</span>: bytes=0-31</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Content-Length</span>: 32</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 0-31/128</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="重定向流程"><a href="#重定向流程" class="headerlink" title="重定向流程"></a>重定向流程</h4><ul>
<li>浏览器发送某个请求/hello</li>
<li>服务器路由规则匹配上这个url后返回302重定向状态码，并在响应头添加Location:/xxx.html</li>
<li>浏览器收到带有Location:/xxx.html的302响应，将使用Loction中url向服务端再次发送请求，并使用这个请求的结果渲染页面</li>
</ul>
<h4 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h4><ul>
<li>301 永久重定向，意思原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新URL，浏览器对301响应做出相应的优化措施，比如保存重定向的URL，下次再有原URL请求是，直接使用新URL，即只做一次请求</li>
<li>302 临时重定向，临时的意思就是浏览器不做额外处理，下次再来原URL请求时，还会走相同的重定向流程</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul>
<li>浏览器发送请求</li>
<li>服务端使用set-Cookie: key=value的响应头</li>
<li>浏览器将key=value保存在本地，下次使用相同域名或者子域名发送请求是，在请求头中设置Cookie:key=value</li>
</ul>
<h4 id="cookie相关属性"><a href="#cookie相关属性" class="headerlink" title="cookie相关属性"></a>cookie相关属性</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: jiangfan=hello; Max-Age=10; Expires=Fri, 23-Aug-19 06:12:27 GMT; Domain=localhost; Path=/; HttpOnly; SameSite=Strict</span><br></pre></td></tr></table></figure>

<p>Expires和Max-Age都表示过期时间，前者表示相对秒数，后者表示过期的绝对时间，两者可以一致，也可以不一致，浏览器优先采用Max-Age来计算失效时间</p>
</li>
<li><p>Domain和path表示域名和路径，浏览器在发送请求前，会先提取url中的域名和路径进行比对，如果不满足条件，则不会带上这个cookie</p>
</li>
<li><p>HttpOnly是服务端告诉浏览器这个cookie只能通过http协议传输，浏览器的js引擎就会禁用和cookie有关的api，以防止脚本攻击</p>
</li>
<li><p>SameSite=Strict可以防范”XSRF“，Strict表示严格限定Cookie不能随着跳转链接跨站发送</p>
</li>
<li><p>Secure表示这个Cooike仅能使用https协议加密传输</p>
</li>
</ul>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><h4 id="服务端的缓存控制"><a href="#服务端的缓存控制" class="headerlink" title="服务端的缓存控制"></a>服务端的缓存控制</h4><ul>
<li>Cache-Control: max-age=10响应头表示服务器通知客户端这次响应内容可以缓存10s，max-age=xxx后面可以跟多个属性字段，例如 no-store， no-cache，must-revalidate，用来实现更复杂的缓存策略</li>
<li>no-store 不允许缓存<ol>
<li>no-cache 可以缓存，但即使在max-age时间范围内（没过期），下次请求时必须先主动向服务端验证是否过期</li>
<li>must-revalidate  可以缓存，只要在max-age时间范围内（没过期），就可以不用主动向服务端验证是否过期直接使用本地缓存</li>
</ol>
</li>
</ul>
<h4 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h4><ul>
<li>Cache-Control这个头字段服务端和客户端都可能使用，即客户端可以使用该头来自己觉得这次请求是否走缓存</li>
<li>Cache-Control: max-age=0 如果客户端使用这个请求头发送请求，表示这次请求不经过缓存直接请求服务端最新的数据，在浏览器刷新页面时，请求头会含有Cache-Control: max-age=0，导致每次刷新页面时都没有检查缓存</li>
<li>浏览器使用Ctrl+F5可以实现”强制刷新”，原理就是在请求时带上”Cache-Control: no-cache”</li>
</ul>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="http1-0短连接"><a href="#http1-0短连接" class="headerlink" title="http1.0短连接"></a>http1.0短连接</h4><ul>
<li>请求完后立即4次挥手关闭连接，下次请求重新3次握手建立连接</li>
<li>从客户端来看每次请求都要建立连接，响应慢</li>
<li>从服务端来看需要使用大量的资源来处理连接的建立和断开，性能很差</li>
</ul>
<h4 id="http1-1长连接"><a href="#http1-1长连接" class="headerlink" title="http1.1长连接"></a>http1.1长连接</h4><ul>
<li><p><img src="/images/network/4.png" alt="network/4.png"></p>
</li>
<li><p>http1.1默认使用长连接</p>
</li>
<li><p>Connection:keep-alive 服务端通知客户端可以使用长连接通信</p>
</li>
<li><p>客户端和服务端都可以主动关闭长连接</p>
</li>
<li><p>Connection:close 客户端使用该请求头通知服务端这次通信完后就会关闭连接，服务端收到该头后，也会返回Connection:close 头，然后调用tcp socket API 关闭tcp连接</p>
</li>
<li><p>nginx支持在服务端主动关闭连，比如nginx使用keepalive_timeout 设置长连接超时时间，超过这段时间客户端仍然没有发送数据，就主动关闭连接，使用keepalive_requeset 设置每个长连接上可发送的最大请求数，超过这个请求数也会主动关闭连接</p>
</li>
<li><p>相对于短连接，减少重复建立和断开连接步骤，但存在http请求的队头阻塞和tcp请求的队头阻塞问题</p>
</li>
</ul>
<h4 id="http队头阻塞"><a href="#http队头阻塞" class="headerlink" title="http队头阻塞"></a>http队头阻塞</h4><ul>
<li><p><img src="/images/network/5.png" alt="network/5.png"></p>
</li>
<li><p>短连接和长连接都存在http队头阻塞，这是http 请求-应答模型决定的</p>
</li>
<li><p>为了更好的解释队头阻塞现象，作如下假定：</p>
<ol>
<li>客户端浏览器对同一个域名只打开一个tcp连接（通常默认是6个）</li>
<li>服务端处理请求时间非常长，假设10s</li>
</ol>
</li>
<li><p>浏览器打开一个页面，发送A请求，此时A页面将在至少10s内无法得到响应，此时再次打开同样的页面，发送同样的请求B（与A复用同一条tcp连接），此时浏览器将不会真的将B的请求发送出去，只会将B的请求入队列，等待A的响应到来后才会发送B请求，这就导致复用同一条tcp连接B请求被hold住，只有A的响应完全被处理之后，浏览器才会真正的发送B请求，这就是所谓的http队头阻塞。</p>
</li>
<li><p>http队头阻塞的本质就是在同一条tcp连接上的http请求必须排队挨个处理，第一个http请求没有得到响应之前，客户端拒绝在同一条tcp连接上发送请求</p>
</li>
<li><p>http1.1针对队头阻塞问题，有以下解决方案：</p>
<ol>
<li>http1.1协议建议客户端使用并发连接，一般浏览器客户端对同一个域名的请求都保持6~8个tcp连接</li>
<li>域名分片，本质上还是提高客户端对某个服务的并发连接数</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/保护模式入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/保护模式入门/" itemprop="url">保护模式入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:40:33+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实模式下的一些问题"><a href="#实模式下的一些问题" class="headerlink" title="实模式下的一些问题"></a>实模式下的一些问题</h3><ol>
<li>实模式下操作系统和用户程序属于同一特权级，没有区别</li>
<li>逻辑地址就是物理地址</li>
<li>用户程序可以修改段基址，所有内存都能够访问到</li>
<li>20根地址线，最大内存1M, 太小</li>
<li>一次只能运行一个程序</li>
<li>实模式下采用 段基址：偏移 访问内存，x86 16位寄存器最大是2^16=64KB自己，显然当访问的内存超过64KB时，就要更改段基址</li>
</ol>
<p>所以有了保护模式。</p>
<p>保护模式（32位）</p>
<ol>
<li>地址线32根，最大内存4G</li>
<li>32位寄存器，直接是可以访问到4G的</li>
<li>段寄存器仍然16位，但是段寄存器中存储的是选择子而不是实模式中的段基址</li>
</ol>
<h3 id="保护模式下的内存访问相关"><a href="#保护模式下的内存访问相关" class="headerlink" title="保护模式下的内存访问相关"></a>保护模式下的内存访问相关</h3><p><img src="/images/11.png" alt="11.jpg"></p>
<p><img src="/images/9.jpg" alt="9.jpg"></p>
<p><img src="/images/8.jpg" alt="8.jpg"></p>
<ul>
<li><p>实例</p>
<p>访问ds:0x9这样的内存,若选择子（段寄存器内容是0x8）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 1000</span><br><span class="line"></span><br><span class="line">RPL: 00 </span><br><span class="line">TI: 0 (表示使用了GDT, 而非LDT)</span><br><span class="line">描述符索引值： 1， (结合TI, 则对应GDT中的第一个描述符）</span><br></pre></td></tr></table></figure>

<p>​    假设第一个描述符 3个基址和起来后的内容是 0x1234,则段基址就是 0x12340x1234:0x9,最后访问的内存地址是0x123d</p>
<h3 id="GDT中的段描述符详解"><a href="#GDT中的段描述符详解" class="headerlink" title="GDT中的段描述符详解"></a>GDT中的段描述符详解</h3><p>参考如下系列文章</p>
<p><a href="http://www.cnblogs.com/longintchar/p/5224405.html" target="_blank" rel="noopener">http://www.cnblogs.com/longintchar/p/5224405.html</a></p>
<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><ul>
<li>boot.S 分析</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">jmp</span> loader_start					<span class="comment">; 此处的物理地址是:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">;limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl已改为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的slot</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line"></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line">   loadermsg <span class="built_in">db</span> <span class="string">'2 loader in real.'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10    功能号:0x13    功能描述:打印字符串</span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入:</span></span><br><span class="line"><span class="comment">;AH 子功能号=13H</span></span><br><span class="line"><span class="comment">;BH = 页码</span></span><br><span class="line"><span class="comment">;BL = 属性(若AL=00H或01H)</span></span><br><span class="line"><span class="comment">;CX＝字符串长度</span></span><br><span class="line"><span class="comment">;(DH、DL)＝坐标(行、列)</span></span><br><span class="line"><span class="comment">;ES:BP＝字符串地址 </span></span><br><span class="line"><span class="comment">;AL＝显示输出方式</span></span><br><span class="line"><span class="comment">;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;   2——字符串中含显示字符和显示属性。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   3——字符串中含显示字符和显示属性。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;无返回值</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">sp</span>, LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bp</span>, loadermsg           <span class="comment">; ES:BP = 字符串地址</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">cx</span>, <span class="number">17</span>			 <span class="comment">; CX = 字符串长度</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">ax</span>, <span class="number">0x1301</span>		 <span class="comment">; AH = 13,  AL = 01h</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bx</span>, <span class="number">0x001f</span>		 <span class="comment">; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">dx</span>, <span class="number">0x1800</span>		 <span class="comment">;</span></span><br><span class="line">   <span class="keyword">int</span>	 <span class="number">0x10</span>                    <span class="comment">; 10h 号中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------   准备进入保护模式   ------------------------------------------</span></span><br><span class="line">									<span class="comment">;1 打开A20</span></span><br><span class="line">									<span class="comment">;2 加载gdt</span></span><br><span class="line">									<span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">   <span class="keyword">jmp</span>  SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">160</span>], <span class="string">'P'</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $</span><br></pre></td></tr></table></figure>

<p>将如下的地址对应到段描述符的高32位中的 0-23位</p>
<ul>
<li>G位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_G_4K   equ	  1_00000000000000000000000b</span><br></pre></td></tr></table></figure>

<p>得到：<br>G=1 代表段基址的粒度是4KB（段界限将达到4G）</p>
<ul>
<li>D位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_D_32   equ	   1_0000000000000000000000b</span><br></pre></td></tr></table></figure>

<p>这里分D和B,1是D,代表数据段，0是B，代表堆栈段</p>
<ul>
<li>type</li>
</ul>
<p><img src="/images/10.jpg" alt="10.jpg"></p>
<ul>
<li>全局描述符表(GDT)的构造</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ;limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl已改为0</span><br></pre></td></tr></table></figure>

<p>​    GDT的三个段描述符： 代码段，堆栈段，显存段；GDT的第0个段不可用段描述符 64bit = 8B(dd是4字节，所以用两个ddd定义一个段描述符)</p>
<p>​    实模式下内存地址 0xb8000到0xbffff是显示适配器BIOS所在区域，当段粒度是4k时，段界限大小为 0xbffff-0xb800/4k = 7, 所以段界限设为7，就足够表示这部分的内存区域了</p>
<ul>
<li>构造选择子（16位，可以索引到段描述符，13位索引+1位TI+2位RPL）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line"></span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br></pre></td></tr></table></figure>

<p>三个选择子的内容分别是（注意索引0是没有用的，这里三个索引1,2,3），都访问GDT而非LDT, 请求特权级都是0级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000   00  0</span><br><span class="line">1   TI_GDT  RPL0</span><br><span class="line">2  TI_GDT  RPL0</span><br><span class="line">3   TI_GDT  RPL0</span><br></pre></td></tr></table></figure>

<ul>
<li>实模式到保护模式的设置和跳转</li>
</ul>
<p>进入保护模式，需要设置控制寄存器的cr0寄存器，其pe位置1，8686要打开A20，这些都在实模式完成，实模式也会设置GDT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure>

<p>GDT由gdtr寄存器加载(gdtr 48bit=6B,前16bit界限，后32bit是起始地址)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">times 60 dq 0					 ; 此处预留60个描述符的slot</span><br><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line"></span><br><span class="line">gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">    dd  GDT_BASE</span><br></pre></td></tr></table></figure>

<ul>
<li>保护模式代码执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &apos;P&apos;</span><br><span class="line"></span><br><span class="line">   jmp $</span><br></pre></td></tr></table></figure>

<p>首先选择子假加载到寄存器，其中0xb8000-0xbfff这个文本显示BIOS内存区域加载到了gs，那么往gs写数据，就是操作0xb8000-0xbfff这块内存，数据也就能正常显示了</p>
<p>按照上一节操作运行后得到的截图， 实模式和保护模式都能显示文本</p>
<p><img src="/images/12.jpg" alt="12.jpg"></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/实模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/实模式/" itemprop="url">实模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T19:21:02+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="本章知识汇总"><a href="#本章知识汇总" class="headerlink" title="本章知识汇总"></a>本章知识汇总</h3><h4 id="什么是地址"><a href="#什么是地址" class="headerlink" title="什么是地址"></a>什么是地址</h4><ul>
<li><p>地址只是数字，描述指令或数据在编译好的二进制文件中的位置，某条指令或者某个数据的地址=指令所在section的虚拟起始地址(vstart)+上述起始虚拟地址到该条指令或数据的偏移量</p>
</li>
<li><p>在汇编语言中如果文件开头使用section xxx vstart=yyy：后面的指令地址都是以yyy为基准进行编排，如果没有使用vstart指定编译地址的基准值，则编译好的二进制文件中的第一个字节的地址就是0x00000000（不管这第一个字节是指令还是数据）</p>
</li>
<li><p>假设纯二进制文件的前3个字节是一条指令，也即第一条指令，那么这条指令的地址就是0x00000000，如果使用vstart指定本文件的起始编排地址是yyy，那么这条指令的地址就是yyy。</p>
</li>
<li><p>如果第一条指令是3个字节长度，如果3个字节之后紧接着仍然是一条指令即第二条指令，那么这条指令的地址是0x00000000+3=0x00000003，如果指定编排的基准的地址vstart=yyy，那么第二条指令的地址就是yyy+3</p>
</li>
<li><p>下面是一段未指定起始虚拟地址的纯二进制文件的反汇编结果：</p>
<p><img src="/images/4.jpg" alt="4.jpg"></p>
<p>第一条指令B80000一共3个字节，那么第二条指令的地址就是0x0000003，第二条指令是8ED8一共2个字节，那么第三条指令的地址就是0x00000005，var dw 0x99表示定义一个双字的数据，值为99，那么代表这个99的变量的地址=vstart为基准+前面所有指令和数据的长度，由于vstart=0，前面5条指令的总大小为0xD，那么这个变量的地址就是0x0000000D。</p>
</li>
<li><p>结论：编译器给程序中各指令或数据编排的地址，本质上就是指令或数据相对于文件开头的偏移量+vstart伪指令指定的虚拟起始地址</p>
</li>
</ul>
<h4 id="section和vstart"><a href="#section和vstart" class="headerlink" title="section和vstart"></a>section和vstart</h4><ul>
<li>section是汇编语言的伪指令，称为节，表示在汇编代码中宣称一块区域</li>
<li>只是为了让汇编程序员在手写汇编代码时能在逻辑上将程序划分成几个部分</li>
<li>section 伪指令配合vstar表示命令编译器在为该section区域的汇编指令编译成二进制指令时，将该section下的第一条指令或数据地址编排为vstart指定的值</li>
</ul>
<p><img src="/images/5.jpg" alt="5.jpg"></p>
<ul>
<li>第9行汇编代码使用伪指令section将10,11,12行的指令在逻辑上划分出来，但是只是用于汇编程序员进行代码的管理和分类，可以看到该行并产生任何机器码指令。</li>
</ul>
<ul>
<li>第5行中的mov ax,$被编译程B8097C，表明在使用section code vstart=0x7c00后，第5行的当前指令所在的地址变成0x7c00+当前指令所在section的真实偏移量0x9（code节的第一条指令距离当前指令的长度）</li>
</ul>
<ul>
<li>第6行中mov ax,[var1] 被编译成A10009，表明使用section data vstart=0x900后，var1变量的地址被编译器编排成了0x900+var1变量所在section的真实偏移量0x0    </li>
</ul>
<h4 id="vstart的作用"><a href="#vstart的作用" class="headerlink" title="vstart的作用"></a>vstart的作用</h4><ul>
<li><p>vstart指令并不会影响二进制文件的大小，比如mbr.s中开头的section mbr vstart=0x7c00，并不会导致编译好的二进制文件在开头会空出0x7c00字节，换句话说不会改变编译好后二级制文件的大小</p>
</li>
<li><p>vstart仅仅会影响汇编文件中的某些符号会被编译器替换成什么样的数值，这些符号通常代表指令或者数据的地址，比如$,$$,var1 dw 0x99中的var1代表0x99这个数据所在的地址等</p>
<ul>
<li>mov ax,$ $是汇编语言中的符号，用来让汇编程序员获取当前指令的地址，但是这个$最终被编译器编排成多少呢？答案是如果没有指定任何vstart，$=当前指令距离文件的偏移量，指定vstart后，$=当前指令距离当前节的偏移量+vstart</li>
<li>var dw 0x99 ；mov ax,[var] 0x99的地址var具体是多少呢？同理，如果没有指定任何vstart，var的值将被编译器编译为距离文件开头的偏移量，指定vstart后，var=数据距离当前节的偏移量+vstart</li>
</ul>
</li>
<li><p>在MBR.S中开头的section mbr vstart=0x7c00的意义：告诉编译器：“嘿，老兄，帮我吧后面所有数据和指令的地址以0x7c00为起始开始编排吧，因为我的前辈（BIOS）会将我所有的内容原封不动的拷贝到0x7c00处，然后跳转到0x7c00继续执行，如果不这样编排地址，我就没法执行了哈”</p>
</li>
</ul>
<h4 id="实模式特点"><a href="#实模式特点" class="headerlink" title="实模式特点"></a>实模式特点</h4><ul>
<li>实模式是指8086CPU的寻址方式，寄存器大小和指令用法等，即CPU在这一套环境下的工作方式</li>
<li>实模式用到的寄存器默认都是16位</li>
<li>8086cpu的地址总线是20位，即访问范围是1MB，即0x0000000~0xFFFFFFF，但是寄存器都是16位，访问20位地址访问的方法：段寄存器中的段基址左移4位+通用寄存器的16为偏移量。</li>
</ul>
<h4 id="实模式的缺陷"><a href="#实模式的缺陷" class="headerlink" title="实模式的缺陷"></a>实模式的缺陷</h4><ul>
<li>安全问题：实模式下，用户程序和操作系统是同一特权级的程序，和操作系统平起平坐，用户程序可以执行具有破坏性的指令</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Jiang Fan">
            
              <p class="site-author-name" itemprop="name">Jiang Fan</p>
              <p class="site-description motion-element" itemprop="description">不积跬步无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Fan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
