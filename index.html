<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="不积跬步无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="Elvis">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Elvis">
<meta property="og:description" content="不积跬步无以至千里">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Elvis">
<meta name="twitter:description" content="不积跬步无以至千里">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Elvis</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Elvis</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/保护模式之内核加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/12/保护模式之内核加载/" itemprop="url">保护模式之内核加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T10:00:30+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="生成内核"><a href="#生成内核" class="headerlink" title="生成内核"></a>生成内核</h3><h4 id="内核源码"><a href="#内核源码" class="headerlink" title="内核源码"></a>内核源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行</li>
<li>使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情</li>
<li>如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知的结果并最终崩溃</li>
</ul>
<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><h5 id="编译main-c得到main-o"><a href="#编译main-c得到main-o" class="headerlink" title="编译main.c得到main.o"></a>编译main.c得到main.o</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o kernel/main.o kernel/main.c</span><br></pre></td></tr></table></figure>

<h5 id="链接main-o得到kernel-bin"><a href="#链接main-o得到kernel-bin" class="headerlink" title="链接main.o得到kernel.bin"></a>链接main.o得到kernel.bin</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin</span><br></pre></td></tr></table></figure>

<ul>
<li>-Ttext 0xc0001500指定该程序的入口地址，这个信息会写入到kernel.bin的文件头中（关于文件头的作用稍后介绍）</li>
<li>-e main 指定起始符号名，代表指定源码中“main”这个符号作为入口符号=0xc0001500，gcc默认入口符号是<em>start而不是main，我们平时编写的程序中虽然没有</em>  _start符号，但是编译时会链接进很多运行库代码，其中肯定有 _start 这个符号，这里我们采用我们平时的习惯，手动指定main函数为入口符号</li>
</ul>
<h3 id="计算机启动过程总结"><a href="#计算机启动过程总结" class="headerlink" title="计算机启动过程总结"></a>计算机启动过程总结</h3><ul>
<li><p>加电，ROM中BIOS开始运行，BIOS将磁盘上MBR加载到BIOS和MRB双方约定的0x7c00处。约定方法：MBR使用vstart告诉汇编编译器编译的起始虚拟地址为0x7c00，然后BIOS将MBR从磁盘上拷贝到内存地址0x7c00处，然后跳转到0x7c00，MBR开始运行</p>
</li>
<li><p>MBR执行完成所有的工作后，将磁盘上的bootloader加载到MBR和bootloader约定好的0x900处，约定方法：bootloader使用vstart告诉汇编编译器编译的起始虚拟地址为0x900，然后MBR将bootloader从磁盘上拷贝到内存地址0x900处，然后跳转到0x900处，loader开始运行</p>
</li>
<li><p>BIOS到MBR，MBR到loader的启动过程很不灵活，调用方需要提前和被调用方约定调用地址，然后调用方将磁盘上的被调用方拷贝到内存中的调用地址处，然后跳转到调用地址处执行</p>
</li>
<li><p>内核是用c语言编写，c编译器编译成的ELF格式的二进制文件，这种文件格式由headr+body组成，headr是程序头信息，里面包含该可执行文件的起始地址，各个段，各个节的信息表</p>
</li>
<li><p>loader需要先将kernel.bin拷贝到内存的某处空闲位置，然后读取分析程序头信息，找到程序入口地址，各个段起始地址，将各个段拷贝到各自的起始起始地址后，跳转到程序的入口地址开始执行，这就是loader加载内核的过程，也是操作系统内核加载用户程序的过程，即分析ELF可执行文件的程序头，将各个段拷贝到文件头中指定的地址处，然后跳转到文件头中指定入口地址处开始执行</p>
</li>
</ul>
<h3 id="ELF格式的二级制文件"><a href="#ELF格式的二级制文件" class="headerlink" title="ELF格式的二级制文件"></a>ELF格式的二级制文件</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>​    在ELF规范中，待重定向文件,共享库文件，和可执行文件都叫做“目标文件”或者ELF文件</p>
<p><img src="/images/24.jpg" alt="24.jpg"></p>
<h4 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h4><p><img src="/images/25.jpg" alt="25.jpg"></p>
<h4 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h4><p><img src="/images/26.jpg" alt="26.jpg"></p>
<p>​    位于文件的开头处，一共16字节，也就是磁盘中二级制可执行文件的前16个字节是这样一个数据结构，下面详细介绍该结构体中重要属性的含义：</p>
<ul>
<li><p>e_ident[16]字节数组，用来表示elf字符信息，开头4字节固定不变，是elf文件的魔数，分别是0x7f，以及字符串“ELF”的asc码：0x45,0x4c，0x46，数组中其他字节见下表</p>
<p><img src="/images/27.jpg" alt="27.jpg"></p>
</li>
<li><p>e_type占2字节，指定elf目标文件的具体类型，各种值代表的文件类型见下表</p>
<p><img src="/images/28.jpg" alt="28.jpg"></p>
</li>
<li><p>e_machine占2字节描述elf目标文件的体系结构类型，就是说该文件只能在哪种硬件平台上运行，可取的值见下表</p>
<p><img src="/images/29.jpg" alt="29.jpg"></p>
</li>
<li><p>e_version 占4字节，用来表示版本信息</p>
</li>
<li><p>e_entry 占用4字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址，就是说加载完程序后跳转到哪个地址上开始执行该进程</p>
</li>
<li><p>e_phoff占4字节，用来指明程序头表（Programma header table）在文件内的字节偏移量</p>
</li>
<li><p>e_shoff占4字节，用来指明节头表（section header table）在文件内的字节偏移量</p>
</li>
<li><p>e_flages占4字节</p>
</li>
<li><p>e_phsize占用2字节，用来指明整个elf header的字节大小，值为16</p>
</li>
<li><p>e_phentsize占2字节，用来指明程序头表（Programma header table）中每个条目的字节大小，该条目的结构是struct Elf32_Phdr，稍后详细介绍</p>
</li>
<li><p>e_phnum占2字节，用来指明程序头表中条目的数量。就是段的个数</p>
</li>
<li><p>e_shentsize占2字节，用来指明节头表每个条目的字节大小</p>
</li>
<li><p>e_shnum占2字节，用来指明节头表中条目的数量，就是节的个数</p>
</li>
<li><p>e_shstrndx占2字节，用来指明string name table在节头表中的索引index</p>
</li>
</ul>
<h4 id="Program-header-table"><a href="#Program-header-table" class="headerlink" title="Program header table"></a>Program header table</h4><p>​    ELF header后面紧接着就是程序头表，所谓表就是数组，里面的元素都是一样的结构体，这个结构体就是struct Elf32_Phdr,下图是这个数组元素结构的定义</p>
<p><img src="/images/30.jpg" alt="30.jpg"></p>
<ul>
<li><p>p_type占4字节，用来指明该段的类型，p_type类型说明见下表</p>
<p><img src="/images/31.jpg" alt="31.jpg"></p>
</li>
<li><p>p_offset占用4字节，用来指明本地在文件内的起始偏移字节</p>
</li>
<li><p>p_vaddr占4字节，用来指明本段在内存中的起始虚拟地址，操作系统通过这个值来将该段拷贝到对应的内存中的虚拟地址处</p>
</li>
<li><p>p_filesz占4字节，用来指明本段在文件中的大小</p>
</li>
<li><p>p_memsz占4字节，用来指明本段在内存中的大小，一般都和p_filesz相等</p>
</li>
<li><p>p_flags占4字节，用来指明与本段相关的标志，此标志取值范围见下表</p>
<p><img src="/images/32.jpg" alt="32.jpg"></p>
</li>
<li><p>p_align占4字节，用来指明本段在文件和内存中的对齐方式，值为0或1表示不对齐</p>
</li>
</ul>
<h4 id="ELF文件实例分析"><a href="#ELF文件实例分析" class="headerlink" title="ELF文件实例分析"></a>ELF文件实例分析</h4><p><img src="/images/33.jpg" alt="33.jpg"></p>
<p>​    上图是xxd命令分析得到的文章开头得到的kernel.bin的二进制文件在磁盘上的字节分布，第一列是文件地址偏移量，中间是文件内容，右边是字节对应的符号，如果是不可见字符用“.”代替。浅下划线代表ELF headr的内容，粗下划线表示段头表，可以看到一共两个段，用“|”分隔开</p>
<p>根据对elf_header 和段头表中第一个段的分析后可以得到以下结论：</p>
<ol>
<li>程序入口地址e_entry的值是0xc0001500</li>
<li>程序第一段需要拷贝到虚拟地址p_vaddr 即0xc0001000处</li>
<li>程序的第一段的大小p_filesz是0x00000505</li>
</ol>
<p>从而可以知道加载器loader所要做的工作：</p>
<ol>
<li>将磁盘中的程序拷贝到一块空闲内存中</li>
<li>分析文件头信息，即elf_header,段头表，节头表，找到文件中第1个段的内容，即开头第0个字节到第0x505个字节，全部拷贝到虚拟地址0xc0001000处，同理找到第二个段的内容，也要拷贝到段头表中第二个元素中指定的虚拟地址处</li>
<li>将所有的段全部拷贝到段头表中各自指定虚拟地址处后，跳转到0xc0001500处开始执行内核代码，可以看到虽然整个程序体有几百字节，但是真正代码段中可执行的指令只有从0xc0001500开始到0xc0001505（0xc0001000+0x505）即5个字节的代码，经过验证main函数中的指令编译成二级制后的确只有5个字节。</li>
</ol>
<h3 id="将内核载入内存"><a href="#将内核载入内存" class="headerlink" title="将内核载入内存"></a>将内核载入内存</h3><h4 id="为什么是0xc0001500"><a href="#为什么是0xc0001500" class="headerlink" title="为什么是0xc0001500"></a>为什么是0xc0001500</h4><p><img src="/images/34.jpg" alt="34.jpg"></p>
<p>​    开启分页后0xc0001500在页表中对应的物理地址是0x00001500，loader在内存中的地址是0x900，而我们在loader中定义了GTD，所以内核代码不能覆盖loader，loader最大不超过2000个字节，0x900+2000=0x10d0，凑个整数，得到0x00001500，对应的虚拟地址为0xc0001500</p>
<h4 id="初始化内核的代码"><a href="#初始化内核的代码" class="headerlink" title="初始化内核的代码"></a>初始化内核的代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">; limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的空位(slot)</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span></span><br><span class="line">   <span class="comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span></span><br><span class="line">   <span class="comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span></span><br><span class="line">   total_mem_bytes <span class="built_in">dd</span> <span class="number">0</span>					 </span><br><span class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line"></span><br><span class="line">   <span class="comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span></span><br><span class="line">   ards_buf <span class="built_in">times</span> <span class="number">244</span> <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   ards_nr <span class="built_in">dw</span> <span class="number">0</span>		      <span class="comment">;用于记录ards结构体数量</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   准备进入保护模式   -------------------</span></span><br><span class="line"><span class="comment">;1 打开A20</span></span><br><span class="line"><span class="comment">;2 加载gdt</span></span><br><span class="line"><span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> <span class="built_in">dword</span> SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"><span class="symbol">.error_hlt:</span>		      <span class="comment">;出错则挂起</span></span><br><span class="line">   <span class="keyword">hlt</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------   加载kernel  ----------------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, KERNEL_START_SECTOR        <span class="comment">; kernel.bin所在的扇区号</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR       <span class="comment">; 从磁盘读出后，写入到ebx指定的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">200</span>			       <span class="comment">; 读入的扇区数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 创建页目录及页表并初始化页内存位图</span></span><br><span class="line">   <span class="keyword">call</span> setup_page</span><br><span class="line"></span><br><span class="line">   <span class="comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span></span><br><span class="line">   <span class="keyword">sgdt</span> [gdt_ptr]	      <span class="comment">; 存储到原来gdt所有的位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [gdt_ptr + <span class="number">2</span>]  </span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">0x18</span> + <span class="number">4</span>], <span class="number">0xc0000000</span>      <span class="comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span></span><br><span class="line">					      <span class="comment">;段描述符的高4字节的最高位是段基址的31~24位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">dword</span> [gdt_ptr + <span class="number">2</span>], <span class="number">0xc0000000</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">0xc0000000</span>        <span class="comment">; 将栈指针同样映射到内核地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr3</span>, eaxx</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;在开启分页后,用gdt新的地址重新加载</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]             <span class="comment">; 重新加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span></span><br><span class="line"><span class="comment">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span></span><br><span class="line">   <span class="keyword">jmp</span> SELECTOR_CODE:enter_kernel	  <span class="comment">;强制刷新流水线,更新gdt</span></span><br><span class="line"><span class="symbol">enter_kernel:</span>    </span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">   <span class="keyword">call</span> kernel_init</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="number">0xc009f000</span></span><br><span class="line">   <span class="keyword">jmp</span> KERNEL_ENTRY_POINT                 <span class="comment">; 用地址0x1500访问测试，结果ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span></span><br><span class="line"><span class="symbol">kernel_init:</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		<span class="comment">;ebx记录程序头表地址</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>		<span class="comment">;cx记录程序头表中的program header数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		<span class="comment">;dx 记录program header尺寸,即e_phentsize</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">42</span>]	  <span class="comment">; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">28</span>]   <span class="comment">; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span></span><br><span class="line">					  <span class="comment">; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">44</span>]    <span class="comment">; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span></span><br><span class="line"><span class="symbol">.each_segment:</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">byte</span> [<span class="built_in">ebx</span> + <span class="number">0</span>], PT_NULL		  <span class="comment">; 若p_type等于 PT_NULL,说明此program header未使用。</span></span><br><span class="line">   <span class="keyword">je</span> .PTNULL</span><br><span class="line"></span><br><span class="line">   <span class="comment">;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">16</span>]		  <span class="comment">; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + <span class="number">4</span>]			  <span class="comment">; 距程序头偏移量为4字节的位置是p_offset</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, KERNEL_BIN_BASE_ADDR	  <span class="comment">; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">eax</span>				  <span class="comment">; 压入函数memcpy的第二个参数:源地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">8</span>]			  <span class="comment">; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span></span><br><span class="line">   <span class="keyword">call</span> mem_cpy				  <span class="comment">; 调用mem_cpy完成段复制</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">12</span>				  <span class="comment">; 清理栈中压入的三个参数</span></span><br><span class="line"><span class="symbol">.PTNULL:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>				  <span class="comment">; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span></span><br><span class="line">   <span class="keyword">loop</span> .each_segment</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span></span><br><span class="line"><span class="comment">;输入:栈中三个参数(dst,src,size)</span></span><br><span class="line"><span class="comment">;输出:无</span></span><br><span class="line"><span class="comment">;---------------------------------------------------------</span></span><br><span class="line"><span class="symbol">mem_cpy:</span>		      </span><br><span class="line">   <span class="keyword">cld</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span>		   <span class="comment">; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]	   <span class="comment">; dst</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + <span class="number">12</span>]	   <span class="comment">; src</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">16</span>]	   <span class="comment">; size</span></span><br><span class="line">   <span class="keyword">rep</span> <span class="keyword">movsb</span>		   <span class="comment">; 逐字节拷贝</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;恢复环境</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ecx</span>		</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性RW和P位为1,US为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">			   <span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_32:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">							 <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">							 <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">							 <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	   <span class="comment">; 备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		   <span class="comment">; 备份扇区数到di</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          x</span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span>		   <span class="comment">;测试0x1f7端口(status寄存器)的的BSY位</span></span><br><span class="line">      <span class="comment">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好,继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span>	   <span class="comment">;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span></span><br><span class="line">			   <span class="comment">;在此先用这种方法,在后面内容会用到insw和outsw等</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span>	   <span class="comment">;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>		</span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">ebx</span>], axx</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">			  <span class="comment">; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span></span><br><span class="line">			  <span class="comment">; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span></span><br><span class="line">			  <span class="comment">; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span></span><br><span class="line">			  <span class="comment">; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span></span><br><span class="line">			  <span class="comment">; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span></span><br><span class="line">			  <span class="comment">; 故程序出会错,不知道会跑到哪里去。</span></span><br><span class="line">			  <span class="comment">; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span></span><br><span class="line">			  <span class="comment">; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span></span><br><span class="line">			  <span class="comment">; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span></span><br><span class="line">			  <span class="comment">; 也会认为要执行的指令是32位.</span></span><br><span class="line">			  <span class="comment">; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span></span><br><span class="line">			  <span class="comment">; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x6x7，</span></span><br><span class="line">			  <span class="comment">; 临时改变当前cpu模式到另外的模式下.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h4 id="内核在低端1MB中的内存布局"><a href="#内核在低端1MB中的内存布局" class="headerlink" title="内核在低端1MB中的内存布局"></a>内核在低端1MB中的内存布局</h4><p><img src="/images/35.jpg" alt="35.jpg"></p>
<ul>
<li><p>0x900处开始是loader，其中loader的开始处是全局描述符表GTD，不能被覆盖，所以内核代码要安置到远离0x900较远的0x1000处（但是从0x1500处开始执行，0x1000到0x1500之间是elf header等内容）</p>
</li>
<li><p>可以看到MBR在0x7c00处，在内核之上，将来内核增大时，肯定会覆盖MBR的代码，不过这无关紧要，因为进入loader后MBR的使命已经完成，被覆盖也无关紧要</p>
</li>
<li><p>内核加载完成后，内核栈指针被设置成了0x9f000，即我们的内核代码在0x00001000到0x0009f000之间</p>
<p><img src="/images/34.jpg" alt="34.jpg"></p>
</li>
<li><p>从上图可以看出，低端1MB可用空间中最高地址是0x9FBFF，那么按理说内核栈指针可以设置到0x9fc00，而我们却选择了0x9f000，乍一看是浪费了0xc00字节的空间，其实不然，选则0x9f000为内核栈指针是因为每个PCB都是自然页，也就是4KB对齐，即类似0x000-0xfff这样，而不是类似0x333-0x1332这样的页内存块，而将来我们会在内核最高处设置内核进程的PCB，所有选择4k整数倍的地址0x9f000</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/11/保护模式之虚拟地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/11/保护模式之虚拟地址/" itemprop="url">保护模式之虚拟地址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T14:32:26+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><h4 id="内存分段机制下的地址访问"><a href="#内存分段机制下的地址访问" class="headerlink" title="内存分段机制下的地址访问"></a>内存分段机制下的地址访问</h4><p><img src="/images/15.jpg" alt="15.jpg"></p>
<h4 id="分段模式存在的问题"><a href="#分段模式存在的问题" class="headerlink" title="分段模式存在的问题"></a>分段模式存在的问题</h4><p><img src="/images/14.jpg" alt="14.jpg"></p>
<p>​    假设内存中同时存在进程A,B,C,他们分别占用10M，20M，30M内存，空余内存15M，如果进程B运行结束，空余20M内存，磁盘中的程序D需要占用20M+3KB的内存，那么这个时候程序D将无法立即被操作系统载入内存运行。如果要运行D程序，有两种解决办法：</p>
<ol>
<li>等待进程A或者进程C运行结束，空出他们所占用的内存</li>
<li>将进程A的A3段或者进程C的C1段换出到磁盘</li>
</ol>
<p>第一种方案需要进程D无期限的等待别的进程结束，这必然无法接受；第二种方案会导致频繁的磁盘IO，但至少是一种可行的解决方案。但是如果进程D需要的内存容量超过系统的所有内存容量（包括已经使用的），那么即使将所有其他进程的内存段换出到磁盘，进程D也无法运行。</p>
<h4 id="如何从根本上解决分段模式问题"><a href="#如何从根本上解决分段模式问题" class="headerlink" title="如何从根本上解决分段模式问题"></a>如何从根本上解决分段模式问题</h4><p>​    CPU认为编译器编译出来的线性地址就是物理地址，线性地址是连续的，所以物理地址也必须要连续才行。换句话说，如果线性地址连续，而物理地址可以不连续，就可以解决上述的所有问题。所有必须解除线性地址于物理地址的相等关系，让线性地址通过某种映射可以对应到物理地址，没错，这种映射关系就是分页模式中的页表</p>
<h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><h4 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h4><p><img src="/images/16.jpg" alt="16.jpg"></p>
<ul>
<li>4GB线性地址空间是指位于磁盘上的被编译器编排好的二进制程序中的线性地址</li>
<li>4GB虚拟地址空间是指每个进程的虚拟地址空间，每个进程都有自己的虚拟地址池，池中也是一页一页的内存块，每个进程也都有自己的虚拟地址位图来管理这些虚拟页</li>
<li>4GB物理地址空间就是只物理内存地址，也是通过物理内存池和位图以页为单位来管理</li>
</ul>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><p>​    现代操作系统都是多级页表，32位操作系统中一般是两级页表，本系列研究32位操作系统，与64位的4级页表原理上是一样的</p>
<p><img src="/images/18.jpg" alt="18.jpg"></p>
<ul>
<li>4GB线性地址空间最多有4GB/4KB=1M个页，将1M个页平均放置到1K个页表中,则每个页表有1M/1K=1K个页表项目，页表项4字节大小，用1K个页表项，则页表的大小为4KB，正好也是一个页的大小</li>
<li>一张页表大小4KB，表中都是页表项PTE，每个页表项4字节大小，共有1024个页表项，每个页表项中存储物理页的实际物理地址和属性信息，即一张页表存储了1024个物理页的实际物理地址和属性信息，能够映射4KB*1024=4MB大小的物理内存。</li>
<li>二级页表一共1M个页表，一个页表映射4MB，则最大能映射4MB*1M=4GB大小的内存，也是32位系统的最大地址范围</li>
<li>由页目录表存储页表的物理地址和属性信息，页目录表一个4KB大小，表中都是4字节大小的页目录，这样可以存储1KB=1024个页表的实际物理地址和属性信息</li>
<li>页目录表和页表是用于管理内存的数据结构，也要占用实际的物理内存，所有页目录表和页表所占用的物理页，同样混迹于物理内存中，如上图所示。</li>
</ul>
<h4 id="虚拟地址到物理地址转换"><a href="#虚拟地址到物理地址转换" class="headerlink" title="虚拟地址到物理地址转换"></a>虚拟地址到物理地址转换</h4><h5 id="转换原理"><a href="#转换原理" class="headerlink" title="转换原理"></a>转换原理</h5><ul>
<li>32位虚拟地址拆分成高10位，中间10位，低12位</li>
<li>高10位作为页目录表的索引，用于在页目录表中定位一个页目录项目PDE，4字节的PDE中有页表物理地址，也就是定位到了某个页表（索引需要乘4）</li>
<li>中间10位作为页表的索引，用于在上述已经定位到的页表中去定位一个页表项目PTE，4字节的PTE中有物理页的物理地址，也就是定位到了某个物理页（索引需要乘4）</li>
<li>低12位作为页内偏移量用于在已经定位到的物理页中寻址（12位正好是1MB，可以逐字节索引）</li>
</ul>
<h5 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h5><ol>
<li>虚拟地址高10位乘4，作为页目录表内的偏移地址，加上页目录表的物理地址（存储中cr3寄存器），所得的和就是页目录项的物理地址，读取该页目录项目，从中获取页表的物理地址</li>
<li>虚拟地址中间10位乘4，作为页表内的偏移量，加上第1步中得到的页表物理地址，所得的和，便是页表项的物理地址，读取该页表项，从中获取到分配的物理页地址</li>
<li>虚拟地址的低12位，作为第2步中得到的物理页的偏移量，即虚拟地址低12位加该物理页的物理地址，所得的和便是最终转换的物理地址</li>
</ol>
<p>这些转换过程由处理器页部件MMU自动完成，下图是以虚拟地址0x1234567为例，给出转换过程</p>
<p><img src="/images/19.jpg" alt="19.jpg"></p>
<h4 id="页目录项和页表项详情"><a href="#页目录项和页表项详情" class="headerlink" title="页目录项和页表项详情"></a>页目录项和页表项详情</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>PDE和PTE除了第7位外，基本相同，第12到第31位共20位表示页表或者物理页的物理地址，因为页表和页目录表的大小都是4KB，而且在内存中的分布都是按照4KB对齐，所有每个页表包括页目录表的物理地址的第12位都是0，所以只要20位足以。</li>
<li>PDE和PTE的第0到第11位都是属性位，记录该页的各种属性</li>
</ul>
<p><img src="/images/20.jpg" alt="20.jpg"></p>
<h5 id="重要属性位"><a href="#重要属性位" class="headerlink" title="重要属性位"></a>重要属性位</h5><ul>
<li>P，Present，P位为1表示该页存在于物理内存中，为0表示该页不存在物理内存中</li>
<li>A，Accessed ，访问位，为1表示被CPU访问过。可以用来记录某一内存页的使用频率，操作系统定期将该位清0，统计一段时间内变成1的次数，从而内存不足时，可以将使用频率较低的页面换出到外存，同时将P为置0，下次访问该页将引起缺页异常，中断处理程序将硬盘上的页再次换入，同时再将P位置1</li>
<li>RW 读写位，1表示可读可写，0表示可读不可写</li>
<li>US 普通用户/超级用户位，为1表示处于User级，任意特权级（0,1,2,3）的程序都可以访问该页，为0表示只允许0,1,2特权级程序访问该页</li>
</ul>
<h3 id="通过页表共享内核地址空间"><a href="#通过页表共享内核地址空间" class="headerlink" title="通过页表共享内核地址空间"></a>通过页表共享内核地址空间</h3><p>​    4GB虚拟地址空间分成2部分，3-4GB地址空间属于内核地址空间，0-3GB属于用户进程地址空间，所有用户进行要共享3-4GB的内核地址空间，这个“共享”的理解如下：</p>
<ul>
<li>操作系统属于内核代码，用户进行调用的内核代码都是在同一份物理内存中，比如中断处理程序，物理内存中仅此一份，所有用户进程都可以调用</li>
<li>用户进程A通过系统调用进入0特权级，并修改或者申请了内核地址空间一块内存，比如申请了一块内存，这块虚拟内存的地址为0xC00090000，当然0xC0009000肯定映射到了某块物理内存，假设该物理内存的首地址为0x12340000。那么0xC0009000这个虚拟地址对应的物理内存块0x12340000，对于其他用户进程也是可以访问的（但要通过系统调用先进入内核态），也就是说，如果用户进程B进入内核态后，直接访问0xC0009000时，操作系统并不会抛出类似”野指针”的这种异常错误，而且用户进程B在内核态访问0xC0009000时，最后访问到的也是同一片物理内存0x12340000，进程间通信中的共享内存方式就是上述的例子，某个进程在内核空间通过系统调用申请一块内存，其他进程同样可以访问到这块内存，虽然是通过文件描述符，但是这个文件描述必然在内核代码中被转换成这块位于内核空间的虚拟内存地址，所有进程都可以通过这个虚拟内存地址去访问这块内存</li>
</ul>
<p>如何通过页表做到以上所说的“共享”呢？其实就是让用户进程3GB-4GB的虚拟地址空间都指向同一个操作系统，也就是所有进程的虚拟地址3GB-4GB本质上都是指向同一片物理页地址。具体实现的方法就是保证所有用户进程虚拟地址空间3GB-4GB对应的页表项中所记录的物理页地址</p>
<h3 id="启用分页"><a href="#启用分页" class="headerlink" title="启用分页"></a>启用分页</h3><h4 id="页目录表和页表的布局"><a href="#页目录表和页表的布局" class="headerlink" title="页目录表和页表的布局"></a>页目录表和页表的布局</h4><p><img src="/images/21.jpg" alt="21.jpg"></p>
<p>​    页目录表位于物理地址0x100000处，即内核1MB以上的最开始处，页表紧挨着页目录表，即第一张页表的物理地址是0x101000，如下图：</p>
<p><img src="/images/22.jpg" alt="22.jpg"></p>
<h4 id="创建页目录表和页表"><a href="#创建页目录表和页表" class="headerlink" title="创建页目录表和页表"></a>创建页目录表和页表</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性US,RW和P位都为1</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h4 id="用虚拟地址访问页表"><a href="#用虚拟地址访问页表" class="headerlink" title="用虚拟地址访问页表"></a>用虚拟地址访问页表</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>​    页表是会动态增加或者删减的，所有在操作系统对内存进行申请或者释放时，会需要在页表中添加页表项目或者删除页表项（使用属性位逻辑删除），所以必须实现这样一个功能：任意给处一个虚拟地址A，我通过某种算法处理一下这个虚拟地址B，然后将这个虚拟地址B提交给CPU地址总线，经过页部件MMU转换后，CPU最终定位到这个虚拟地址A所对应的页目录项的实现物理地址，也可以定位到这个虚拟地址A所对应的页表项的实际物理地址。</p>
<h5 id="页目录表设计"><a href="#页目录表设计" class="headerlink" title="页目录表设计"></a>页目录表设计</h5><ul>
<li>页目录表第768页目录项中的物理地址指向第一张页表，代表0xC0000000～0xC0010000这1MB内存映射到低端0x00000000~0x00010000这1MB</li>
<li>页目录表的第0个页目录项的物理地址也指向第一张页表，原因是兼容分段机制</li>
<li>页目录的最后一下即第1023个页目录中的物理地址指向页目录表本身的物理地址，即0x00010000</li>
</ul>
<h5 id="获取能够访问页表项的虚拟地址算法"><a href="#获取能够访问页表项的虚拟地址算法" class="headerlink" title="获取能够访问页表项的虚拟地址算法"></a>获取能够访问页表项的虚拟地址算法</h5><p>​    假设有虚拟地址A，那么：</p>
<ul>
<li>页目录表的物理地址：使用虚拟地址B：0xFFFFF000，就可以访问到页目录表本身的地址</li>
<li>可以访问到A对应页目录项的虚拟地址B：0xFFFFFXXX，其中XXX为虚拟地址A的高10位</li>
<li>可以访问到A对应的页表项的虚拟地址B：高10位都为1，即0x3FF，中间10位是虚拟地址A的高10位，低12为虚拟地址A的中间10乘4</li>
</ul>
<h3 id="TLB简介"><a href="#TLB简介" class="headerlink" title="TLB简介"></a>TLB简介</h3><p>​    通过虚拟地址得到物理地址的过程比较复杂，要查页表，做乘法，页表本身处于内存中，内存对于CPU来说是低俗设备，如果每次寻址都要做一遍转换的话，效率太低，所以处理器准备一种高速缓存，专门用来存放虚拟地址页框与物理地址页框的映射关系，这个高速缓存就是TLB，俗称“快表”</p>
<p><img src="/images/23.jpg" alt="23.jpg"></p>
<p>​    每次向处理器提交虚拟地址时，会使用该地址的高20位（低12位无意义）去查找对应的物理页地址的高20位，如果缓存命中，就不会去走虚拟地址到物理地址的漫长转换，如果没命中，则会去查页表最后获得物理页的物理地址，然后更新TLB</p>
<p>​    TLB容量很小，只有当前任务的的部分页表，而且只有P位为1的页表项才有资格在TLB中，如果TLB装满了，需要将最少使用频率的页的条目换出</p>
<p>​    进程间切换相对于线程间切换的一个劣势就是，进程间切换会导致TLB中的条目全部失效，缓存全部无法命中</p>
<p>​    TLB的更新是由操作系统来更新的，因为CPU不知道何时修改或者更新了页表，只有操作系统知道何时更改了页表，所以只能由操作系统负载去更新，更新TLB的指令有两种，一种是重新加载cr3寄存器，这将导致整个TLB失效，另一种是使用invlp m,m表示要更新的虚拟内存地址</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/golang默认打开RESUSEADDR选项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/golang默认打开RESUSEADDR选项/" itemprop="url">golang默认打开RESUSEADDR选项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T12:41:37+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="REUSEADDR"><a href="#REUSEADDR" class="headerlink" title="REUSEADDR"></a>REUSEADDR</h3><ul>
<li><p>c语言中的socket选项，默认是0即不打开</p>
</li>
<li><p>主要用于服务端如果在运行过程中出现主动关闭情况时（一般情况都是被动关闭），服务端的在本机的监听端口将处于TIME_WAIT状态，此时如果重启服务器的话将出现bind: address already in use错误，必须等2MSL的时间后，才能重启成功</p>
</li>
<li><p>打开REUSEADDR选项后，即使监听端口处于TIME_WAIT状态，依然可以正常bind并启动成功</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<h3 id="echoserver主动关闭连接实验"><a href="#echoserver主动关闭连接实验" class="headerlink" title="echoserver主动关闭连接实验"></a>echoserver主动关闭连接实验</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	host <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">""</span>, <span class="string">"host"</span>)</span><br><span class="line">	flag.StringVar(&amp;port, <span class="string">"p"</span>, <span class="string">"3333"</span>, <span class="string">"port"</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">var</span> l *net.TCPListener</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line"></span><br><span class="line">	tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, host+<span class="string">":"</span>+port)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	l, err = net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err = l.Accept()</span><br><span class="line">		fmt.Printf(<span class="string">"client:%s connect\n"</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleClient(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> readstr <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		n, err = conn.Read(buf)</span><br><span class="line">		conn.Close()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"client:%s closed\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			readstr = strings.ToUpper(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">			_, err = conn.Write([]<span class="keyword">byte</span>(readstr))</span><br><span class="line">			checkError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"Fatal error:%s\n"</span>, err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    echoserver读到客户端数据时，变直接调用conn.close()主动关闭（为了模拟服务端监听端口出现TIME_WAIT）echoserver以本地网卡10.129.21.36，并监听端口5000 启动，使用nc 127.0.0.1 8000 进行连接，端口占用情况如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000   0.0.0.0:*         LISTEN      30236/./echoserver  </span><br><span class="line">tcp     0       10.129.21.36:5000   127.0.0.1:8000    ESTABLISHED 30236/./echoserver  </span><br><span class="line">tcp     0       127.0.0.1:8000      10.129.21.36:5000 ESTABLISHED 30254/./echoclient</span><br></pre></td></tr></table></figure>

<p>​    在nc中输入任意字符串并回车后,echoserver会立即主动关闭连接并退出进程，监听端口5000出现TIME_WAIT状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000   127.0.0.1:8000    TIME_WAIT   -</span><br></pre></td></tr></table></figure>

<p>​    此时如果echoserver进程重新以5000监听端口启动，不会报错，启动成功，并且用netstat查看xuanx10.129.21.36这张网卡的5000端口同时出现Listen 和TIME_WAIT状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp     0       10.129.21.36:5000    0.0.0.0:*         LISTEN     31281/./echoserver  </span><br><span class="line">tcp     0       10.129.21.36:5000    127.0.0.1:8000    TIME_WAIT  -</span><br></pre></td></tr></table></figure>

<p>​    可以看到新的echoserver进程（pid为31281，之前的pid为30236）正常启动，并监听在5000端口，同时之前的echoserver进程的127.0.0.1:8000-&gt;10.129.21.36:5000的连接由于服务端主动关闭连接动作而导致10.129.21.36的5000端口变成TIME_WAIT状态，但是新的echoserver进行依然能使用10.129.21.36:5000正常绑定和监听</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    从实验结果来看，golang的net包在创建server时，默认启用REUSEADDR这个socket选项</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/golang实现echoserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/06/golang实现echoserver/" itemprop="url">golang实现echoserver</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T09:56:40+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="echoserver"><a href="#echoserver" class="headerlink" title="echoserver"></a>echoserver</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	host <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">""</span>, <span class="string">"host"</span>)</span><br><span class="line">	flag.StringVar(&amp;port, <span class="string">"p"</span>, <span class="string">"3333"</span>, <span class="string">"port"</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">var</span> l *net.TCPListener</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line"></span><br><span class="line">	tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, host+<span class="string">":"</span>+port)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	l, err = net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		conn, err = l.Accept()</span><br><span class="line">		fmt.Printf(<span class="string">"client:%s connect\n"</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleClient(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> readstr <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		n, err = conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"client:%s closed\n"</span>, conn.RemoteAddr().String())</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			readstr = strings.ToUpper(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">			_, err = conn.Write([]<span class="keyword">byte</span>(readstr))</span><br><span class="line">			checkError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"Fatal error:%s\n"</span>, err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接受客户端连接后起一个协程处理客户端发来的数据</li>
<li>对客户端发来的英文字符串转大写后回写客户端</li>
<li>服务端执行被动关闭，当客户端发起主动关闭时，服务端将读到EOF，并执行被动关闭</li>
</ul>
<h3 id="echoclient"><a href="#echoclient" class="headerlink" title="echoclient"></a>echoclient</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	remoteAddr <span class="keyword">string</span></span><br><span class="line">	remotePort <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">	flag.StringVar(&amp;remoteAddr,<span class="string">"h"</span>,<span class="string">"127.0.0.1"</span>,<span class="string">"remoteAddr"</span>)</span><br><span class="line">	flag.StringVar(&amp;remotePort,<span class="string">"p"</span>,<span class="string">"3333"</span>,<span class="string">"remotePort"</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> tcpAddr *net.TCPAddr</span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line">	<span class="keyword">var</span> buf =<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">var</span> temp []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> inputReader=bufio.NewReader(os.Stdin)</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">	tcpAddr,err=net.ResolveTCPAddr(<span class="string">"tcp"</span>,remoteAddr+<span class="string">":"</span>+remotePort)</span><br><span class="line">	checkError(err)</span><br><span class="line">	conn,err=net.DialTCP(<span class="string">"tcp"</span>,<span class="literal">nil</span>,tcpAddr)</span><br><span class="line">	checkError(err)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">		temp,err=inputReader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">		checkError(err)</span><br><span class="line">		_,err=conn.Write(temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stderr,<span class="string">"Fatal error:%s\n"</span>,err.Error())</span><br><span class="line">			conn.Close()</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n,err=conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">"server closed"</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="keyword">string</span>(buf[<span class="number">0</span>:n]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr,<span class="string">"Fatal error:%s\n"</span>,err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端读入标准输入的数据发送服务端，接受服务端回写的数据到标准输出</li>
<li>如果服务端退出，客户端将读到EOF，客户端同时关闭连接并退出</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个最简单的使用golang实现的c/s模型echoserver，虽然看起来简单，但其实只是golang对c语言中epoll多路复用模型的封装</li>
<li>今后的网络编程的学习中将以这个echoserver为例，对场景的问题场景进行复现和分析</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/TIMEWAIT和端口复用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/TIMEWAIT和端口复用/" itemprop="url">TIMEWAIT和端口复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T16:23:08+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    TIME_WAIT和端口复用这两个概念既有区别又有联系，很多人认为端口复用是用来专门解决TIME_WAIT，其实这是一种错误的认知，错就错在“专门”上，端口复用的主要解决的是服务器进程快速重启、单进程accept调用的并发瓶颈和“惊群”效应，本文将详细介绍TIME_WAIT状态存在的必要性、原因以及减少TIME_WAIT数量的方法，然后介绍实现端口复用的两个socket选项：REFUSEADDR和REFUSEPORT,用具体的示例来说明这两个选项的最常用的使用场景。</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><h4 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h4><p><img src="/images/network/8.png" alt="network/8.png">    </p>
<p>主动发起关闭动作的一方在收到对端发来的FIN报文并发送ACK后，进入TIME_WIAT状态，这个状态持续的时间是固定的2MSL，大约120s</p>
<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><ul>
<li>如果没有TIME_WAIT，主动关闭方调用close，向对端发送FIN后直接进入close状态，那么这条tcp连接的上下文将被立即释放，此时如果对端也调用close，发送FIN报文后，由于在主动方这条连接已经不存在，主动方只能发送一个RST复位报文，那么被动方就会出现错误</li>
<li>持续2MSL这么长时间的目的是为了让主动关闭放的最后一个ACK能让被动方接受，同时可以让“迷走报文”能够有足够长的时间游荡在网络中，从而被网络丢弃，否则这些”迷走报文”将对新建立的连接产生影响</li>
</ul>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul>
<li>socket=(本地ip，本地port，远端ip，远端port），当进程作为一个客户端对一个已知ip和port的远端服务端发起连接时，在这个连接对应的socket中，本地ip固定，远端ip和远端port都已固定，只有16位的本地port是操作系统临时分配的，所有操作系统能允许对同一个远端服务器进程同时建立的连接数=2的16次方，即65535，而操作系统前1024个端口号不允许用户进程占用，所以真正可以使用端口号的范围为1024~65535</li>
<li>内存资源占用，但几乎可以忽略不计</li>
<li>端口资源占用，比如nginx在做反向代理时，即是客户端的也是服务端，当作为客户端反向代理到上游服务器建立tcp连接时，如果nginx主动关闭对上游服务的连接，此时这个连接状态就会变成TIME_WAIT,在反向代理是有内核分配的端口将不能被使用，当与上游服务器建立大量的tcp短连接时，nginx所在的机器就会出现大量的TIME_WAIT,直到消耗尽系统的端口数量，此时服务就会出现时而能访问，时而又不能访问的诡异现象优化</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>​    调整内核参数，设置net.ipv4.tcp_tw_reuse=1，调整完后，nginx向上游服务器发起断开连接的请求后，只需过1s，这个断开的处于TIME_WAIT的状态的端口就可以再次被nginx用来向上游服务器用来建立连接</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    从以上叙述看来，TIME_WAIT和端口复用没有太大的关联，解决TIME_WAIT数量过多的最有效方法也只是适用进程作为客户端对外发起大量连接，而端口复用于TIME_WAIT唯一的联系就是，某一个端口处在TIME_WAIT状态，而这个端口又是某个服务进场启动时候的监听端口时，开启端口复用选项可以让服务进程立即启动，而不必等待2MSL的时间，当然这只是端口复用的一个使用场景，端口复用还有另一个使用场景就是让多个进程（通常是子进程）同时监听相同端口，当有客户端建立连接的请求过来时，由内核通过某种负载均衡策略将连接转移到不同进程上，目的是解决有大量客户端同时建立连接时，单进程accept调用的瓶颈（对正在建立连接的请求有数量限制，即listen函数的第二个参数，默认是1024，表示同时想服务进程进行三次握手动作的客户端的最大数量，注意是仅仅指正在进行三次握手动作的客户端数量，不包括建立好连接的客户端数量）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/Http协议核心知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Http协议核心知识/" itemprop="url">Http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T09:29:35+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/网络协议/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ul>
<li>灵活可扩展 </li>
<li>可靠传输</li>
<li>请求-应答通信模型</li>
<li>无状态</li>
</ul>
<h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul>
<li>明文不安全</li>
<li>队头阻塞性能差</li>
</ul>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><h4 id="数据类型、编码和语言"><a href="#数据类型、编码和语言" class="headerlink" title="数据类型、编码和语言"></a>数据类型、编码和语言</h4><ul>
<li><p>Accept客户端告诉服务器我这次请求能支持的响应数据类型,例如Accept:text/html,application/xml,image/webp,image</p>
</li>
<li><p>Content-Type服务器通知客户端段返回的数据类型，例如Content-Type: text/html</p>
</li>
<li><p>Accept-Encoding客户端通知服务器支持的压缩格式，例如Accept-Encoding: gzip, deflate, br</p>
</li>
<li><p>Content-Encoding服务器通知客户端所使用的压缩算法，例如Content-Encoding: gzip</p>
</li>
<li><p>Accept-Language客户端告诉服务器可以理解的自然语言，例如Accept-Language: zh-CN, zh, en</p>
</li>
<li><p>Content-Language服务端告诉客户端返回数据的实际语言,例如Content-Language: zh-CN</p>
</li>
<li><p>Accept-Charset客户端通知服务端我支持的字符集，例如Accept-Charset: gbk, utf-8，但是服务端返回的字符集类型存在于Content-Type中，例如Content-Type: text/html; charset=utf-8</p>
</li>
<li><p>客户端可以使用权重q=value来告诉服务端客户端的“喜好”，q的范围为0.01~1，默认是1。例如Accept: text/html,application/xml;q=0.9,<em>/</em>;q=0.8（最喜欢权重为1的html，其次是权重为0.9的xml，最后是权重是0.8的任意数据）</p>
</li>
</ul>
<h4 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h4><ul>
<li><p>分块传输常用于大文件的流式传输，可以实现变传输变渲染，提高用户体验</p>
</li>
<li><p>Transfer-Encoding: chunked 服务端告诉客户端响应数据是分块传输的，你需要按照我们定好的分块传输格式提取每个分块的内容，然后组合在一起，过程中客户端与服务器的连接仍然维持不会断开。</p>
</li>
<li><p>每个分块数据的格式：分块长度+分块数据，每个部分都用CRLF来分隔，客户端根据这个分隔符和分块长度正确提取每个分块的数据，并使用一个分块长度为0的”结束分块“来告知客户端所有分块传输完毕</p>
</li>
<li><p><img src="/images/network/1.png" alt="network/1.png"></p>
</li>
</ul>
<ul>
<li>Transfer-Encoding: chunked 和Content-Length不能同时使用，Content-Length表示一次完成的请求中传输的所有内容长度；而分块传输的所有分块都只是一次=请求中未完成的一部分，具体现象见下图</li>
<li><img src="/images/network/2.gif" alt="network/2.gif"></li>
</ul>
<h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><ul>
<li><p>范围请求常用于视频播放中的进度条拖到，跳过片头等功能</p>
</li>
<li><p>Range 客户端使用Range:bytes=0-50 通知服务端只返回响应的0~50个字节，可以指定多个范围，用”,”分隔</p>
</li>
<li><p>服务端接受到客户端的Range请求后要做以下3件事情：</p>
<ol>
<li>检查客户端要求的范围是否合法，如果超出响应数据的范围，返回416错误码</li>
<li>范围正确，根据请求头Range头计算偏移量，截取对应数据，并返回206状态吗</li>
<li>添加响应头Content-Range头，例如Content-Range:bytes 0-10/100，表示这次请求按照你的要求返回了0-10字节的内容，整个文件的内容长度是100字节</li>
</ol>
</li>
<li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.test.com</span><br><span class="line"><span class="attribute">Range</span>: bytes=0-31</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Content-Length</span>: 32</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 0-31/128</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="重定向流程"><a href="#重定向流程" class="headerlink" title="重定向流程"></a>重定向流程</h4><ul>
<li>浏览器发送某个请求/hello</li>
<li>服务器路由规则匹配上这个url后返回302重定向状态码，并在响应头添加Location:/xxx.html</li>
<li>浏览器收到带有Location:/xxx.html的302响应，将使用Loction中url向服务端再次发送请求，并使用这个请求的结果渲染页面</li>
</ul>
<h4 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h4><ul>
<li>301 永久重定向，意思原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新URL，浏览器对301响应做出相应的优化措施，比如保存重定向的URL，下次再有原URL请求是，直接使用新URL，即只做一次请求</li>
<li>302 临时重定向，临时的意思就是浏览器不做额外处理，下次再来原URL请求时，还会走相同的重定向流程</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul>
<li>浏览器发送请求</li>
<li>服务端使用set-Cookie: key=value的响应头</li>
<li>浏览器将key=value保存在本地，下次使用相同域名或者子域名发送请求是，在请求头中设置Cookie:key=value</li>
</ul>
<h4 id="cookie相关属性"><a href="#cookie相关属性" class="headerlink" title="cookie相关属性"></a>cookie相关属性</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: jiangfan=hello; Max-Age=10; Expires=Fri, 23-Aug-19 06:12:27 GMT; Domain=localhost; Path=/; HttpOnly; SameSite=Strict</span><br></pre></td></tr></table></figure>

<p>Expires和Max-Age都表示过期时间，前者表示相对秒数，后者表示过期的绝对时间，两者可以一致，也可以不一致，浏览器优先采用Max-Age来计算失效时间</p>
</li>
<li><p>Domain和path表示域名和路径，浏览器在发送请求前，会先提取url中的域名和路径进行比对，如果不满足条件，则不会带上这个cookie</p>
</li>
<li><p>HttpOnly是服务端告诉浏览器这个cookie只能通过http协议传输，浏览器的js引擎就会禁用和cookie有关的api，以防止脚本攻击</p>
</li>
<li><p>SameSite=Strict可以防范”XSRF“，Strict表示严格限定Cookie不能随着跳转链接跨站发送</p>
</li>
<li><p>Secure表示这个Cooike仅能使用https协议加密传输</p>
</li>
</ul>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><h4 id="服务端的缓存控制"><a href="#服务端的缓存控制" class="headerlink" title="服务端的缓存控制"></a>服务端的缓存控制</h4><ul>
<li>Cache-Control: max-age=10响应头表示服务器通知客户端这次响应内容可以缓存10s，max-age=xxx后面可以跟多个属性字段，例如 no-store， no-cache，must-revalidate，用来实现更复杂的缓存策略</li>
<li>no-store 不允许缓存<ol>
<li>no-cache 可以缓存，但即使在max-age时间范围内（没过期），下次请求时必须先主动向服务端验证是否过期</li>
<li>must-revalidate  可以缓存，只要在max-age时间范围内（没过期），就可以不用主动向服务端验证是否过期直接使用本地缓存</li>
</ol>
</li>
</ul>
<h4 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h4><ul>
<li>Cache-Control这个头字段服务端和客户端都可能使用，即客户端可以使用该头来自己觉得这次请求是否走缓存</li>
<li>Cache-Control: max-age=0 如果客户端使用这个请求头发送请求，表示这次请求不经过缓存直接请求服务端最新的数据，在浏览器刷新页面时，请求头会含有Cache-Control: max-age=0，导致每次刷新页面时都没有检查缓存</li>
<li>浏览器使用Ctrl+F5可以实现”强制刷新”，原理就是在请求时带上”Cache-Control: no-cache”</li>
</ul>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="http1-0短连接"><a href="#http1-0短连接" class="headerlink" title="http1.0短连接"></a>http1.0短连接</h4><ul>
<li>请求完后立即4次挥手关闭连接，下次请求重新3次握手建立连接</li>
<li>从客户端来看每次请求都要建立连接，响应慢</li>
<li>从服务端来看需要使用大量的资源来处理连接的建立和断开，性能很差</li>
</ul>
<h4 id="http1-1长连接"><a href="#http1-1长连接" class="headerlink" title="http1.1长连接"></a>http1.1长连接</h4><ul>
<li><p><img src="/images/network/4.png" alt="network/4.png"></p>
</li>
<li><p>http1.1默认使用长连接</p>
</li>
<li><p>Connection:keep-alive 服务端通知客户端可以使用长连接通信</p>
</li>
<li><p>客户端和服务端都可以主动关闭长连接</p>
</li>
<li><p>Connection:close 客户端使用该请求头通知服务端这次通信完后就会关闭连接，服务端收到该头后，也会返回Connection:close 头，然后调用tcp socket API 关闭tcp连接</p>
</li>
<li><p>nginx支持在服务端主动关闭连，比如nginx使用keepalive_timeout 设置长连接超时时间，超过这段时间客户端仍然没有发送数据，就主动关闭连接，使用keepalive_requeset 设置每个长连接上可发送的最大请求数，超过这个请求数也会主动关闭连接</p>
</li>
<li><p>相对于短连接，减少重复建立和断开连接步骤，但存在http请求的队头阻塞和tcp请求的队头阻塞问题</p>
</li>
</ul>
<h4 id="http队头阻塞"><a href="#http队头阻塞" class="headerlink" title="http队头阻塞"></a>http队头阻塞</h4><ul>
<li><p><img src="/images/network/5.png" alt="network/5.png"></p>
</li>
<li><p>短连接和长连接都存在http队头阻塞，这是http 请求-应答模型决定的</p>
</li>
<li><p>为了更好的解释队头阻塞现象，作如下假定：</p>
<ol>
<li>客户端浏览器对同一个域名只打开一个tcp连接（通常默认是6个）</li>
<li>服务端处理请求时间非常长，假设10s</li>
</ol>
</li>
<li><p>浏览器打开一个页面，发送A请求，此时A页面将在至少10s内无法得到响应，此时再次打开同样的页面，发送同样的请求B（与A复用同一条tcp连接），此时浏览器将不会真的将B的请求发送出去，只会将B的请求入队列，等待A的响应到来后才会发送B请求，这就导致复用同一条tcp连接B请求被hold住，只有A的响应完全被处理之后，浏览器才会真正的发送B请求，这就是所谓的http队头阻塞。</p>
</li>
<li><p>http队头阻塞的本质就是在同一条tcp连接上的http请求必须排队挨个处理，第一个http请求没有得到响应之前，客户端拒绝在同一条tcp连接上发送请求</p>
</li>
<li><p>http1.1针对队头阻塞问题，有以下解决方案：</p>
<ol>
<li>http1.1协议建议客户端使用并发连接，一般浏览器客户端对同一个域名的请求都保持6~8个tcp连接</li>
<li>域名分片，本质上还是提高客户端对某个服务的并发连接数</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/保护模式入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/保护模式入门/" itemprop="url">保护模式入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:40:33+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实模式下的一些问题"><a href="#实模式下的一些问题" class="headerlink" title="实模式下的一些问题"></a>实模式下的一些问题</h3><ol>
<li>实模式下操作系统和用户程序属于同一特权级，没有区别</li>
<li>逻辑地址就是物理地址</li>
<li>用户程序可以修改段基址，所有内存都能够访问到</li>
<li>20根地址线，最大内存1M, 太小</li>
<li>一次只能运行一个程序</li>
<li>实模式下采用 段基址：偏移 访问内存，x86 16位寄存器最大是2^16=64KB自己，显然当访问的内存超过64KB时，就要更改段基址</li>
</ol>
<p>所以有了保护模式。</p>
<p>保护模式（32位）</p>
<ol>
<li>地址线32根，最大内存4G</li>
<li>32位寄存器，直接是可以访问到4G的</li>
<li>段寄存器仍然16位，但是段寄存器中存储的是选择子而不是实模式中的段基址</li>
</ol>
<h3 id="保护模式下的内存访问相关"><a href="#保护模式下的内存访问相关" class="headerlink" title="保护模式下的内存访问相关"></a>保护模式下的内存访问相关</h3><p><img src="/images/11.png" alt="11.jpg"></p>
<p><img src="/images/9.jpg" alt="9.jpg"></p>
<p><img src="/images/8.jpg" alt="8.jpg"></p>
<ul>
<li><p>实例</p>
<p>访问ds:0x9这样的内存,若选择子（段寄存器内容是0x8）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 1000</span><br><span class="line"></span><br><span class="line">RPL: 00 </span><br><span class="line">TI: 0 (表示使用了GDT, 而非LDT)</span><br><span class="line">描述符索引值： 1， (结合TI, 则对应GDT中的第一个描述符）</span><br></pre></td></tr></table></figure>

<p>​    假设第一个描述符 3个基址和起来后的内容是 0x1234,则段基址就是 0x12340x1234:0x9,最后访问的内存地址是0x123d</p>
<h3 id="GDT中的段描述符详解"><a href="#GDT中的段描述符详解" class="headerlink" title="GDT中的段描述符详解"></a>GDT中的段描述符详解</h3><p>参考如下系列文章</p>
<p><a href="http://www.cnblogs.com/longintchar/p/5224405.html" target="_blank" rel="noopener">http://www.cnblogs.com/longintchar/p/5224405.html</a></p>
<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><ul>
<li>boot.S 分析</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">jmp</span> loader_start					<span class="comment">; 此处的物理地址是:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">;limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl已改为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的slot</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line"></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line">   loadermsg <span class="built_in">db</span> <span class="string">'2 loader in real.'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10    功能号:0x13    功能描述:打印字符串</span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入:</span></span><br><span class="line"><span class="comment">;AH 子功能号=13H</span></span><br><span class="line"><span class="comment">;BH = 页码</span></span><br><span class="line"><span class="comment">;BL = 属性(若AL=00H或01H)</span></span><br><span class="line"><span class="comment">;CX＝字符串长度</span></span><br><span class="line"><span class="comment">;(DH、DL)＝坐标(行、列)</span></span><br><span class="line"><span class="comment">;ES:BP＝字符串地址 </span></span><br><span class="line"><span class="comment">;AL＝显示输出方式</span></span><br><span class="line"><span class="comment">;   0——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;   2——字符串中含显示字符和显示属性。显示后，光标位置不变</span></span><br><span class="line"><span class="comment">;   3——字符串中含显示字符和显示属性。显示后，光标位置改变</span></span><br><span class="line"><span class="comment">;无返回值</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">sp</span>, LOADER_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bp</span>, loadermsg           <span class="comment">; ES:BP = 字符串地址</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">cx</span>, <span class="number">17</span>			 <span class="comment">; CX = 字符串长度</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">ax</span>, <span class="number">0x1301</span>		 <span class="comment">; AH = 13,  AL = 01h</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">bx</span>, <span class="number">0x001f</span>		 <span class="comment">; 页号为0(BH = 0) 蓝底粉红字(BL = 1fh)</span></span><br><span class="line">   <span class="keyword">mov</span>	 <span class="built_in">dx</span>, <span class="number">0x1800</span>		 <span class="comment">;</span></span><br><span class="line">   <span class="keyword">int</span>	 <span class="number">0x10</span>                    <span class="comment">; 10h 号中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------   准备进入保护模式   ------------------------------------------</span></span><br><span class="line">									<span class="comment">;1 打开A20</span></span><br><span class="line">									<span class="comment">;2 加载gdt</span></span><br><span class="line">									<span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">   <span class="keyword">jmp</span>  SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">160</span>], <span class="string">'P'</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $</span><br></pre></td></tr></table></figure>

<p>将如下的地址对应到段描述符的高32位中的 0-23位</p>
<ul>
<li>G位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_G_4K   equ	  1_00000000000000000000000b</span><br></pre></td></tr></table></figure>

<p>得到：<br>G=1 代表段基址的粒度是4KB（段界限将达到4G）</p>
<ul>
<li>D位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC_D_32   equ	   1_0000000000000000000000b</span><br></pre></td></tr></table></figure>

<p>这里分D和B,1是D,代表数据段，0是B，代表堆栈段</p>
<ul>
<li>type</li>
</ul>
<p><img src="/images/10.jpg" alt="10.jpg"></p>
<ul>
<li>全局描述符表(GDT)的构造</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ;limit=(0xbffff-0xb8000)/4k=0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl已改为0</span><br></pre></td></tr></table></figure>

<p>​    GDT的三个段描述符： 代码段，堆栈段，显存段；GDT的第0个段不可用段描述符 64bit = 8B(dd是4字节，所以用两个ddd定义一个段描述符)</p>
<p>​    实模式下内存地址 0xb8000到0xbffff是显示适配器BIOS所在区域，当段粒度是4k时，段界限大小为 0xbffff-0xb800/4k = 7, 所以段界限设为7，就足够表示这部分的内存区域了</p>
<ul>
<li>构造选择子（16位，可以索引到段描述符，13位索引+1位TI+2位RPL）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line"></span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br></pre></td></tr></table></figure>

<p>三个选择子的内容分别是（注意索引0是没有用的，这里三个索引1,2,3），都访问GDT而非LDT, 请求特权级都是0级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000   00  0</span><br><span class="line">1   TI_GDT  RPL0</span><br><span class="line">2  TI_GDT  RPL0</span><br><span class="line">3   TI_GDT  RPL0</span><br></pre></td></tr></table></figure>

<ul>
<li>实模式到保护模式的设置和跳转</li>
</ul>
<p>进入保护模式，需要设置控制寄存器的cr0寄存器，其pe位置1，8686要打开A20，这些都在实模式完成，实模式也会设置GDT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]</span><br></pre></td></tr></table></figure>

<p>GDT由gdtr寄存器加载(gdtr 48bit=6B,前16bit界限，后32bit是起始地址)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">times 60 dq 0					 ; 此处预留60个描述符的slot</span><br><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line"></span><br><span class="line">gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">    dd  GDT_BASE</span><br></pre></td></tr></table></figure>

<ul>
<li>保护模式代码执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &apos;P&apos;</span><br><span class="line"></span><br><span class="line">   jmp $</span><br></pre></td></tr></table></figure>

<p>首先选择子假加载到寄存器，其中0xb8000-0xbfff这个文本显示BIOS内存区域加载到了gs，那么往gs写数据，就是操作0xb8000-0xbfff这块内存，数据也就能正常显示了</p>
<p>按照上一节操作运行后得到的截图， 实模式和保护模式都能显示文本</p>
<p><img src="/images/12.jpg" alt="12.jpg"></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/实模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/实模式/" itemprop="url">实模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T19:21:02+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="本章知识汇总"><a href="#本章知识汇总" class="headerlink" title="本章知识汇总"></a>本章知识汇总</h3><h4 id="什么是地址"><a href="#什么是地址" class="headerlink" title="什么是地址"></a>什么是地址</h4><ul>
<li><p>地址只是数字，描述指令或数据在编译好的二进制文件中的位置，某条指令或者某个数据的地址=指令所在section的虚拟起始地址(vstart)+上述起始虚拟地址到该条指令或数据的偏移量</p>
</li>
<li><p>在汇编语言中如果文件开头使用section xxx vstart=yyy：后面的指令地址都是以yyy为基准进行编排，如果没有使用vstart指定编译地址的基准值，则编译好的二进制文件中的第一个字节的地址就是0x00000000（不管这第一个字节是指令还是数据）</p>
</li>
<li><p>假设纯二进制文件的前3个字节是一条指令，也即第一条指令，那么这条指令的地址就是0x00000000，如果使用vstart指定本文件的起始编排地址是yyy，那么这条指令的地址就是yyy。</p>
</li>
<li><p>如果第一条指令是3个字节长度，如果3个字节之后紧接着仍然是一条指令即第二条指令，那么这条指令的地址是0x00000000+3=0x00000003，如果指定编排的基准的地址vstart=yyy，那么第二条指令的地址就是yyy+3</p>
</li>
<li><p>下面是一段未指定起始虚拟地址的纯二进制文件的反汇编结果：</p>
<p><img src="/images/4.jpg" alt="4.jpg"></p>
<p>第一条指令B80000一共3个字节，那么第二条指令的地址就是0x0000003，第二条指令是8ED8一共2个字节，那么第三条指令的地址就是0x00000005，var dw 0x99表示定义一个双字的数据，值为99，那么代表这个99的变量的地址=vstart为基准+前面所有指令和数据的长度，由于vstart=0，前面5条指令的总大小为0xD，那么这个变量的地址就是0x0000000D。</p>
</li>
<li><p>结论：编译器给程序中各指令或数据编排的地址，本质上就是指令或数据相对于文件开头的偏移量+vstart伪指令指定的虚拟起始地址</p>
</li>
</ul>
<h4 id="section和vstart"><a href="#section和vstart" class="headerlink" title="section和vstart"></a>section和vstart</h4><ul>
<li>section是汇编语言的伪指令，称为节，表示在汇编代码中宣称一块区域</li>
<li>只是为了让汇编程序员在手写汇编代码时能在逻辑上将程序划分成几个部分</li>
<li>section 伪指令配合vstar表示命令编译器在为该section区域的汇编指令编译成二进制指令时，将该section下的第一条指令或数据地址编排为vstart指定的值</li>
</ul>
<p><img src="/images/5.jpg" alt="5.jpg"></p>
<ul>
<li>第9行汇编代码使用伪指令section将10,11,12行的指令在逻辑上划分出来，但是只是用于汇编程序员进行代码的管理和分类，可以看到该行并产生任何机器码指令。</li>
</ul>
<ul>
<li>第5行中的mov ax,$被编译程B8097C，表明在使用section code vstart=0x7c00后，第5行的当前指令所在的地址变成0x7c00+当前指令所在section的真实偏移量0x9（code节的第一条指令距离当前指令的长度）</li>
</ul>
<ul>
<li>第6行中mov ax,[var1] 被编译成A10009，表明使用section data vstart=0x900后，var1变量的地址被编译器编排成了0x900+var1变量所在section的真实偏移量0x0    </li>
</ul>
<h4 id="vstart的作用"><a href="#vstart的作用" class="headerlink" title="vstart的作用"></a>vstart的作用</h4><ul>
<li><p>vstart指令并不会影响二进制文件的大小，比如mbr.s中开头的section mbr vstart=0x7c00，并不会导致编译好的二进制文件在开头会空出0x7c00字节，换句话说不会改变编译好后二级制文件的大小</p>
</li>
<li><p>vstart仅仅会影响汇编文件中的某些符号会被编译器替换成什么样的数值，这些符号通常代表指令或者数据的地址，比如$,$$,var1 dw 0x99中的var1代表0x99这个数据所在的地址等</p>
<ul>
<li>mov ax,$ $是汇编语言中的符号，用来让汇编程序员获取当前指令的地址，但是这个$最终被编译器编排成多少呢？答案是如果没有指定任何vstart，$=当前指令距离文件的偏移量，指定vstart后，$=当前指令距离当前节的偏移量+vstart</li>
<li>var dw 0x99 ；mov ax,[var] 0x99的地址var具体是多少呢？同理，如果没有指定任何vstart，var的值将被编译器编译为距离文件开头的偏移量，指定vstart后，var=数据距离当前节的偏移量+vstart</li>
</ul>
</li>
<li><p>在MBR.S中开头的section mbr vstart=0x7c00的意义：告诉编译器：“嘿，老兄，帮我吧后面所有数据和指令的地址以0x7c00为起始开始编排吧，因为我的前辈（BIOS）会将我所有的内容原封不动的拷贝到0x7c00处，然后跳转到0x7c00继续执行，如果不这样编排地址，我就没法执行了哈”</p>
</li>
</ul>
<h4 id="实模式特点"><a href="#实模式特点" class="headerlink" title="实模式特点"></a>实模式特点</h4><ul>
<li>实模式是指8086CPU的寻址方式，寄存器大小和指令用法等，即CPU在这一套环境下的工作方式</li>
<li>实模式用到的寄存器默认都是16位</li>
<li>8086cpu的地址总线是20位，即访问范围是1MB，即0x0000000~0xFFFFFFF，但是寄存器都是16位，访问20位地址访问的方法：段寄存器中的段基址左移4位+通用寄存器的16为偏移量。</li>
</ul>
<h4 id="实模式的缺陷"><a href="#实模式的缺陷" class="headerlink" title="实模式的缺陷"></a>实模式的缺陷</h4><ul>
<li>安全问题：实模式下，用户程序和操作系统是同一特权级的程序，和操作系统平起平坐，用户程序可以执行具有破坏性的指令</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/nginx负载均衡策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/nginx负载均衡策略/" itemprop="url">nginx负载均衡策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T12:57:19+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务端开发/" itemprop="url" rel="index">
                    <span itemprop="name">服务端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/服务端开发/nginx/" itemprop="url" rel="index">
                    <span itemprop="name">nginx</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基于加权Round-Robin的负载均衡"><a href="#基于加权Round-Robin的负载均衡" class="headerlink" title="基于加权Round-Robin的负载均衡"></a>基于加权Round-Robin的负载均衡</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> roundrobin &#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8012</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8013</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8014</span> down;</span><br><span class="line">	<span class="attribute">keepalive</span> <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">server_name</span> nginx.roundrobin.learn;</span><br><span class="line">	<span class="attribute">error_log</span> /etc/nginx/logs/learn/83_roundrobin_error.log <span class="literal">notice</span>;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://roundrobin;</span><br><span class="line">		<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h4><ul>
<li>upstream 指令定义一组上游服务，该组上游服务的地址由upstream指令块中的server指令指定</li>
<li>server指令指定该组上游服务中某一台服务器的地址，地址可以是ipv4，ipv6和unixsocket，可以指定端口号，默认使用80</li>
<li>server指令中ip地址后可以添加多种参数来定义这台服务器的负载均衡策略<ul>
<li>weight=2表示选择权重是2（默认是1）;</li>
<li>max_conns=2表示对这台上游服务的最大连接数（只作用与单个worker进程，总的连接数=worker进场数量*max_conns）</li>
<li>max_fails=2和fail_timeout=5组合在一起表示如果在5秒内对这台server的失败请求数到达2，则在下一个5秒中的后续请求将不会转发到该server</li>
<li>backup表示该server仅仅作为备份server，当其他server出现故障或者下线时，nginx会将请求转发到该server</li>
<li>donw表示该server已经下线，不在服务</li>
</ul>
</li>
<li>keepalive 32 表示nginx保持对该组上游服务的最大长连接数为32个长连接</li>
<li>proxy_http_version 1.1  表示nginx作为客户端要求roundrobin上游服务使用http1.1协议</li>
<li>proxy_set_header Connection 是为了防止nginx的下游客户端对nginx使用Connection：close这种header，此时不置空的话会导致nginx作为客户端对上游服务的请求采用短连接的方式</li>
</ul>
<h4 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h4><ul>
<li>round-robin负载均衡策略配置简单，能够进行快速的水平扩展</li>
<li>只适用与无状态服务，不适用于有状态的服务，比如每台server中都保留根据用户信息（比如ip）或者根据用户请求参数所对应的数据</li>
</ul>
<h3 id="基于upstream-ip-hash模块的负载均衡"><a href="#基于upstream-ip-hash模块的负载均衡" class="headerlink" title="基于upstream_ip_hash模块的负载均衡"></a>基于upstream_ip_hash模块的负载均衡</h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> iphashups &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8012</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">set_real_ip_from</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">real_ip_recursive</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line">	<span class="attribute">server_name</span> nginx.iphash.learn;</span><br><span class="line">	<span class="attribute">error_log</span> /etc/nginx/logs/learn/84_iphash_error.log <span class="literal">notice</span>;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://iphashups;</span><br><span class="line">		<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置详解-1"><a href="#配置详解-1" class="headerlink" title="配置详解"></a>配置详解</h4><ul>
<li>ip_hash 指令表示nginx会对remote_addr使用hash算法，根据hash的结果将该用户的请求转发到特定的server</li>
<li>$remote_addr应该确保得到的是用户的真实ip，所以upstream_ip_hash模块需要配合real_ip模块来获取真实用户ip</li>
</ul>
<h4 id="优缺点和使用场景-1"><a href="#优缺点和使用场景-1" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h4><ul>
<li>适用于将用户ip和上游sever进行黏合的有状态服务</li>
<li>仅仅只能根据用户ip，不够灵活</li>
<li>当某台server下线或者扩展添加sever时，将导致nginx根据之前hash结果的路由路径全部失效，如果上游服务有根据用户ip所对应的本地缓存，会导致缓存在这一瞬间全部失效</li>
</ul>
<h3 id="基于upstream-hash模块的负载均衡"><a href="#基于upstream-hash模块的负载均衡" class="headerlink" title="基于upstream_hash模块的负载均衡"></a>基于upstream_hash模块的负载均衡</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> iphashups &#123;</span><br><span class="line">	<span class="attribute">hash</span>   <span class="variable">$arg_username</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8012</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">set_real_ip_from</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">real_ip_recursive</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line">	<span class="attribute">server_name</span> nginx.hash.learn;</span><br><span class="line">	<span class="attribute">error_log</span> /etc/nginx/logs/learn/84_hash_error.log <span class="literal">notice</span>;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://iphashups;</span><br><span class="line">		<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置详解-2"><a href="#配置详解-2" class="headerlink" title="配置详解"></a>配置详解</h4><ul>
<li>hash 指令将对用户传入的请求参数进行hash算法，根据hash的结果将本次请求转发到某台server，如本例中的$arg_username，url参数中如果有username=xiaoming，nginx将会提取到”xiaoming“这个字符串用做hash算法的输入</li>
</ul>
<h4 id="优缺点和使用场景-2"><a href="#优缺点和使用场景-2" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h4><ul>
<li>可以灵活的将用户传入的任意参数与上游sever进行黏合</li>
<li>于upstream_ip_hash相同，当某台server下线或者扩展添加sever时，将导致nginx根据之前hash结果的路由路径全部失效，如果上游服务有根据用户参数所对应的本地缓存，会导致缓存在这一瞬间全部失效</li>
</ul>
<h3 id="基于一致性Hash算法的负载均衡"><a href="#基于一致性Hash算法的负载均衡" class="headerlink" title="基于一致性Hash算法的负载均衡"></a>基于一致性Hash算法的负载均衡</h3><h4 id="Hash算法的问题"><a href="#Hash算法的问题" class="headerlink" title="Hash算法的问题"></a>Hash算法的问题</h4><ul>
<li>宕机或者扩容时，hash算法引发大量路由变更，可能导致上游sever的本地缓存大范围失效</li>
</ul>
<h4 id="一致性hash算法优点"><a href="#一致性hash算法优点" class="headerlink" title="一致性hash算法优点"></a>一致性hash算法优点</h4><ul>
<li>宕机或者扩容时，只会落在使得宕机或者扩容节点与邻近节点之间的请求所对应的本地缓存失效，大部分节点server中的缓存不受影响</li>
</ul>
<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> iphashups &#123;</span><br><span class="line">	<span class="attribute">hash</span>   <span class="variable">$arg_username</span> consistent;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8011</span> weight=<span class="number">2</span> max_conns=<span class="number">2</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8012</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">set_real_ip_from</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">real_ip_recursive</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br><span class="line">	<span class="attribute">server_name</span> nginx.hash.learn;</span><br><span class="line">	<span class="attribute">error_log</span> /etc/nginx/logs/learn/84_hash_error.log <span class="literal">notice</span>;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://iphashups;</span><br><span class="line">		<span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置详解-3"><a href="#配置详解-3" class="headerlink" title="配置详解"></a>配置详解</h4><ul>
<li>upstream_hash模块中的 hash key指令后跟上 consistent 选项即可开启一致性hash功能</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/BIOS到MBR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/BIOS到MBR/" itemprop="url">BIOS到MBR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:40:33+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="本章知识汇总"><a href="#本章知识汇总" class="headerlink" title="本章知识汇总"></a>本章知识汇总</h3><h4 id="实模式下1MB寻址范围布局"><a href="#实模式下1MB寻址范围布局" class="headerlink" title="实模式下1MB寻址范围布局"></a>实模式下1MB寻址范围布局</h4><p><img src="/images/1.jpg" alt="1.jpg"></p>
<h4 id="什么叫“程序载入内存”"><a href="#什么叫“程序载入内存”" class="headerlink" title="什么叫“程序载入内存”"></a>什么叫“程序载入内存”</h4><ol>
<li>程序被加载器（软件或硬件）加载到内存的某个区域</li>
<li>CPU的cs:ip寄存器被指向这个程序的起始地址</li>
</ol>
<h4 id="主板上的物理内存不是cpu寻址的全部范围"><a href="#主板上的物理内存不是cpu寻址的全部范围" class="headerlink" title="主板上的物理内存不是cpu寻址的全部范围"></a>主板上的物理内存不是cpu寻址的全部范围</h4><p><img src="/images/3.jpg" alt="2.jpg"></p>
<ol>
<li>地址总线宽度决定计算机在寻址上可以到达的疆域，寻址的内容不仅包括主板上的物理内存，虽然大部分的地址范围都被映射到了主板内存上，但cpu仍然需要保留一部分地址范围另做他用，包括映射保存BIOS代码的ROM，显卡、磁盘、键盘等外设中的内存等，这就是为什么我们购买的4Gb内存条，在32位操作系统（cpu地址总线也是32位）中安装完后只显示3.8G，并不是显卡制造商“掺水”，而是因为32位地址范围不能全部分配给4Gb主板内存，还有留出一部分地址范围用作映射ROM和外设内存。</li>
<li>举个例子：当cs:ip中的内容落在映射到BIOS的rom范围中，便到达了直接执行BIOS中的目的，即在执行BIOS时，cpu是直接从静态ROM中取指令，不是去主板内存中取指令，因为BIOS根本就不在内存中。cpu在硬件级别做了强制约定，只要寻址落在了这个特殊的范围，就是直接去这块保持有BIOS指令的ROM中取指令和数据</li>
</ol>
<h4 id="BIOS是如何启动的"><a href="#BIOS是如何启动的" class="headerlink" title="BIOS是如何启动的"></a>BIOS是如何启动的</h4><ol>
<li><p>BIOS存在于静态ROM上，而非主板内存中，BIOS本质上也是一段代码指令，BIOS的入口地址是0xFFFFO</p>
</li>
<li><p>机器加电时，进入实模式，cpu的指令指针寄存器被强制设置成0xF000:0xFFF0,即0xF000*4+0xFFF0=0xFFFF0</p>
</li>
<li><p>0xFFFF0离实模式最大寻址范围的0XFFFFF（1MB）只有16字节，根本无法容纳BIOS的所有指令，所以该处的指令仅仅是一个跳转指令jmp far f000:e05b=0xfe05b，cpu跳转到此处后，开始执行BIOS的实质工作内容</p>
</li>
</ol>
<h4 id="BIOS做了哪些重要的事情"><a href="#BIOS做了哪些重要的事情" class="headerlink" title="BIOS做了哪些重要的事情"></a>BIOS做了哪些重要的事情</h4><ol>
<li>检测、初始化硬件</li>
<li>建立中断向量表，可以通过”中断号”进行相关硬件调用，仅仅是简单基础的I/O操作，这也是BIOS命名的由来（基础输入输出系统）</li>
<li>校验启动盘位于0盘0道1扇区的内容是否是mbr，判断这512字节中的最后两个字节是否是魔数0x55，0xaa</li>
<li>校验成功，确定该扇区内容是MBR，则将该扇区的内容即MBR加载到0x7c00(所谓的加载其实就是BIOS读取硬盘中该扇区的内容，并将该扇区的内容拷贝到0x7c00处，和把一段内存拷贝到另一段内存没有本质的区别)。</li>
<li>加载完MBR到0x7c00后，执行jmp 0:0x7c00跳转到0x7c00，MRB自此便登上计算机生命的舞台</li>
</ol>
<h4 id="MBR开头的sction-MBR-vstart-0x7c00"><a href="#MBR开头的sction-MBR-vstart-0x7c00" class="headerlink" title="MBR开头的sction MBR vstart=0x7c00"></a>MBR开头的sction MBR vstart=0x7c00</h4><ol>
<li><p>该指令的作用是告诉编译器，本源码文件在编译时，将起始地址编译为0x7c00，然后后面的指令和数据的地址都是以0x7c00为基准进行编址</p>
</li>
<li><p>MBR运行在实模式下，实模式中的地址对应与内存中的真实物理地址，在BIOS中已经将MBR从磁盘上拷贝到内存中的0x7c00，为了能正确执行和寻址MBR中的指令和数据，必须将程序的起始地址编译成0x7c00。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;主引导程序 </span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span>         </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>      </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>           <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">   <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">0x184f</span>	   <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">			   <span class="comment">; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span><br><span class="line">			   <span class="comment">; 下标从0开始,所以0x18=24,0x4f=79</span></span><br><span class="line">   <span class="keyword">int</span>     <span class="number">0x10</span>            <span class="comment">; int 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span></span><br><span class="line"><span class="comment">;.get_cursor获取当前光标位置,在光标位置处打印字符.</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">3</span>		<span class="comment">; 输入: 3号子功能是获取光标位置,需要存入ah寄存器</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span>		<span class="comment">; bh寄存器存储的是待获取光标的页号</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x10</span>		<span class="comment">; 输出: ch=光标开始行,cl=光标结束行</span></span><br><span class="line">			<span class="comment">; dh=光标所在行号,dl=光标所在列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span></span><br><span class="line">   <span class="comment">;还是用10h中断,不过这次是调用13号子功能打印字符串</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, message </span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">ax</span>		<span class="comment">; es:bp 为串首地址, es此时同cs一致，</span></span><br><span class="line">			<span class="comment">; 开头时已经为sreg初始化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span>		<span class="comment">; cx 为串长度,不包括结束符0的字符个数</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span>	<span class="comment">; 子功能号13是显示字符及属性,要存入ah寄存器,</span></span><br><span class="line">			<span class="comment">; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x2</span>		<span class="comment">; bh存储要显示的页号,此处是第0页,</span></span><br><span class="line">			<span class="comment">; bl中是字符属性, 属性黑底绿字(bl = 02h)</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x10</span>		<span class="comment">; 执行BIOS 0x10 号中断</span></span><br><span class="line"><span class="comment">;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> $		<span class="comment">; 使程序悬停在此</span></span><br><span class="line"></span><br><span class="line">   message <span class="built_in">db</span> <span class="string">"1 MBR"</span></span><br><span class="line">   <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>&lt;&lt;操作系统真相还原&gt;&gt;</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Jiang Fan">
            
              <p class="site-author-name" itemprop="name">Jiang Fan</p>
              <p class="site-description motion-element" itemprop="description">不积跬步无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Fan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
