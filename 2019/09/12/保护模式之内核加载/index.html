<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="os,">










<meta name="description" content="生成内核内核源码1234int main(void) &amp;#123;   while(1);   return 0;&amp;#125;   代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行 使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情 如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知">
<meta name="keywords" content="os">
<meta property="og:type" content="article">
<meta property="og:title" content="保护模式之内核加载">
<meta property="og:url" content="http://yoursite.com/2019/09/12/保护模式之内核加载/index.html">
<meta property="og:site_name" content="Elvis">
<meta property="og:description" content="生成内核内核源码1234int main(void) &amp;#123;   while(1);   return 0;&amp;#125;   代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行 使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情 如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/24.jpg">
<meta property="og:image" content="http://yoursite.com/images/25.jpg">
<meta property="og:image" content="http://yoursite.com/images/26.jpg">
<meta property="og:image" content="http://yoursite.com/images/27.jpg">
<meta property="og:image" content="http://yoursite.com/images/28.jpg">
<meta property="og:image" content="http://yoursite.com/images/29.jpg">
<meta property="og:image" content="http://yoursite.com/images/30.jpg">
<meta property="og:image" content="http://yoursite.com/images/31.jpg">
<meta property="og:image" content="http://yoursite.com/images/32.jpg">
<meta property="og:image" content="http://yoursite.com/images/33.jpg">
<meta property="og:image" content="http://yoursite.com/images/34.jpg">
<meta property="og:image" content="http://yoursite.com/images/35.jpg">
<meta property="og:image" content="http://yoursite.com/images/34.jpg">
<meta property="og:updated_time" content="2019-09-12T09:50:21.382Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="保护模式之内核加载">
<meta name="twitter:description" content="生成内核内核源码1234int main(void) &amp;#123;   while(1);   return 0;&amp;#125;   代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行 使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情 如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知">
<meta name="twitter:image" content="http://yoursite.com/images/24.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/12/保护模式之内核加载/">





  <title>保护模式之内核加载 | Elvis</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Elvis</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/保护模式之内核加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Elvis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">保护模式之内核加载</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T10:00:30+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="生成内核"><a href="#生成内核" class="headerlink" title="生成内核"></a>生成内核</h3><h4 id="内核源码"><a href="#内核源码" class="headerlink" title="内核源码"></a>内核源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码虽然简单，但是只要能起到演示内核是如何被加载到内存中运行就行</li>
<li>使用while(1)死循环，其实真正的操作系统内核就本质上也是死循环，只不过真正的内核在循环体中做了非常多的事情</li>
<li>如果不用while(1)死循环，CPU会一往无前的从内存中取指令运行下去，会出现不可预知的结果并最终崩溃</li>
</ul>
<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><h5 id="编译main-c得到main-o"><a href="#编译main-c得到main-o" class="headerlink" title="编译main.c得到main.o"></a>编译main.c得到main.o</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o kernel/main.o kernel/main.c</span><br></pre></td></tr></table></figure>

<h5 id="链接main-o得到kernel-bin"><a href="#链接main-o得到kernel-bin" class="headerlink" title="链接main.o得到kernel.bin"></a>链接main.o得到kernel.bin</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin</span><br></pre></td></tr></table></figure>

<ul>
<li>-Ttext 0xc0001500指定该程序的入口地址，这个信息会写入到kernel.bin的文件头中（关于文件头的作用稍后介绍）</li>
<li>-e main 指定起始符号名，代表指定源码中“main”这个符号作为入口符号=0xc0001500，gcc默认入口符号是<em>start而不是main，我们平时编写的程序中虽然没有</em>  _start符号，但是编译时会链接进很多运行库代码，其中肯定有 _start 这个符号，这里我们采用我们平时的习惯，手动指定main函数为入口符号</li>
</ul>
<h3 id="计算机启动过程总结"><a href="#计算机启动过程总结" class="headerlink" title="计算机启动过程总结"></a>计算机启动过程总结</h3><ul>
<li><p>加电，ROM中BIOS开始运行，BIOS将磁盘上MBR加载到BIOS和MRB双方约定的0x7c00处。约定方法：MBR使用vstart告诉汇编编译器编译的起始虚拟地址为0x7c00，然后BIOS将MBR从磁盘上拷贝到内存地址0x7c00处，然后跳转到0x7c00，MBR开始运行</p>
</li>
<li><p>MBR执行完成所有的工作后，将磁盘上的bootloader加载到MBR和bootloader约定好的0x900处，约定方法：bootloader使用vstart告诉汇编编译器编译的起始虚拟地址为0x900，然后MBR将bootloader从磁盘上拷贝到内存地址0x900处，然后跳转到0x900处，loader开始运行</p>
</li>
<li><p>BIOS到MBR，MBR到loader的启动过程很不灵活，调用方需要提前和被调用方约定调用地址，然后调用方将磁盘上的被调用方拷贝到内存中的调用地址处，然后跳转到调用地址处执行</p>
</li>
<li><p>内核是用c语言编写，c编译器编译成的ELF格式的二进制文件，这种文件格式由headr+body组成，headr是程序头信息，里面包含该可执行文件的起始地址，各个段，各个节的信息表</p>
</li>
<li><p>loader需要先将kernel.bin拷贝到内存的某处空闲位置，然后读取分析程序头信息，找到程序入口地址，各个段起始地址，将各个段拷贝到各自的起始起始地址后，跳转到程序的入口地址开始执行，这就是loader加载内核的过程，也是操作系统内核加载用户程序的过程，即分析ELF可执行文件的程序头，将各个段拷贝到文件头中指定的地址处，然后跳转到文件头中指定入口地址处开始执行</p>
</li>
</ul>
<h3 id="ELF格式的二级制文件"><a href="#ELF格式的二级制文件" class="headerlink" title="ELF格式的二级制文件"></a>ELF格式的二级制文件</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>​    在ELF规范中，待重定向文件,共享库文件，和可执行文件都叫做“目标文件”或者ELF文件</p>
<p><img src="/images/24.jpg" alt="24.jpg"></p>
<h4 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h4><p><img src="/images/25.jpg" alt="25.jpg"></p>
<h4 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h4><p><img src="/images/26.jpg" alt="26.jpg"></p>
<p>​    位于文件的开头处，一共16字节，也就是磁盘中二级制可执行文件的前16个字节是这样一个数据结构，下面详细介绍该结构体中重要属性的含义：</p>
<ul>
<li><p>e_ident[16]字节数组，用来表示elf字符信息，开头4字节固定不变，是elf文件的魔数，分别是0x7f，以及字符串“ELF”的asc码：0x45,0x4c，0x46，数组中其他字节见下表</p>
<p><img src="/images/27.jpg" alt="27.jpg"></p>
</li>
<li><p>e_type占2字节，指定elf目标文件的具体类型，各种值代表的文件类型见下表</p>
<p><img src="/images/28.jpg" alt="28.jpg"></p>
</li>
<li><p>e_machine占2字节描述elf目标文件的体系结构类型，就是说该文件只能在哪种硬件平台上运行，可取的值见下表</p>
<p><img src="/images/29.jpg" alt="29.jpg"></p>
</li>
<li><p>e_version 占4字节，用来表示版本信息</p>
</li>
<li><p>e_entry 占用4字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址，就是说加载完程序后跳转到哪个地址上开始执行该进程</p>
</li>
<li><p>e_phoff占4字节，用来指明程序头表（Programma header table）在文件内的字节偏移量</p>
</li>
<li><p>e_shoff占4字节，用来指明节头表（section header table）在文件内的字节偏移量</p>
</li>
<li><p>e_flages占4字节</p>
</li>
<li><p>e_phsize占用2字节，用来指明整个elf header的字节大小，值为16</p>
</li>
<li><p>e_phentsize占2字节，用来指明程序头表（Programma header table）中每个条目的字节大小，该条目的结构是struct Elf32_Phdr，稍后详细介绍</p>
</li>
<li><p>e_phnum占2字节，用来指明程序头表中条目的数量。就是段的个数</p>
</li>
<li><p>e_shentsize占2字节，用来指明节头表每个条目的字节大小</p>
</li>
<li><p>e_shnum占2字节，用来指明节头表中条目的数量，就是节的个数</p>
</li>
<li><p>e_shstrndx占2字节，用来指明string name table在节头表中的索引index</p>
</li>
</ul>
<h4 id="Program-header-table"><a href="#Program-header-table" class="headerlink" title="Program header table"></a>Program header table</h4><p>​    ELF header后面紧接着就是程序头表，所谓表就是数组，里面的元素都是一样的结构体，这个结构体就是struct Elf32_Phdr,下图是这个数组元素结构的定义</p>
<p><img src="/images/30.jpg" alt="30.jpg"></p>
<ul>
<li><p>p_type占4字节，用来指明该段的类型，p_type类型说明见下表</p>
<p><img src="/images/31.jpg" alt="31.jpg"></p>
</li>
<li><p>p_offset占用4字节，用来指明本地在文件内的起始偏移字节</p>
</li>
<li><p>p_vaddr占4字节，用来指明本段在内存中的起始虚拟地址，操作系统通过这个值来将该段拷贝到对应的内存中的虚拟地址处</p>
</li>
<li><p>p_filesz占4字节，用来指明本段在文件中的大小</p>
</li>
<li><p>p_memsz占4字节，用来指明本段在内存中的大小，一般都和p_filesz相等</p>
</li>
<li><p>p_flags占4字节，用来指明与本段相关的标志，此标志取值范围见下表</p>
<p><img src="/images/32.jpg" alt="32.jpg"></p>
</li>
<li><p>p_align占4字节，用来指明本段在文件和内存中的对齐方式，值为0或1表示不对齐</p>
</li>
</ul>
<h4 id="ELF文件实例分析"><a href="#ELF文件实例分析" class="headerlink" title="ELF文件实例分析"></a>ELF文件实例分析</h4><p><img src="/images/33.jpg" alt="33.jpg"></p>
<p>​    上图是xxd命令分析得到的文章开头得到的kernel.bin的二进制文件在磁盘上的字节分布，第一列是文件地址偏移量，中间是文件内容，右边是字节对应的符号，如果是不可见字符用“.”代替。浅下划线代表ELF headr的内容，粗下划线表示段头表，可以看到一共两个段，用“|”分隔开</p>
<p>根据对elf_header 和段头表中第一个段的分析后可以得到以下结论：</p>
<ol>
<li>程序入口地址e_entry的值是0xc0001500</li>
<li>程序第一段需要拷贝到虚拟地址p_vaddr 即0xc0001000处</li>
<li>程序的第一段的大小p_filesz是0x00000505</li>
</ol>
<p>从而可以知道加载器loader所要做的工作：</p>
<ol>
<li>将磁盘中的程序拷贝到一块空闲内存中</li>
<li>分析文件头信息，即elf_header,段头表，节头表，找到文件中第1个段的内容，即开头第0个字节到第0x505个字节，全部拷贝到虚拟地址0xc0001000处，同理找到第二个段的内容，也要拷贝到段头表中第二个元素中指定的虚拟地址处</li>
<li>将所有的段全部拷贝到段头表中各自指定虚拟地址处后，跳转到0xc0001500处开始执行内核代码，可以看到虽然整个程序体有几百字节，但是真正代码段中可执行的指令只有从0xc0001500开始到0xc0001505（0xc0001000+0x505）即5个字节的代码，经过验证main函数中的指令编译成二级制后的确只有5个字节。</li>
</ol>
<h3 id="将内核载入内存"><a href="#将内核载入内存" class="headerlink" title="将内核载入内存"></a>将内核载入内存</h3><h4 id="为什么是0xc0001500"><a href="#为什么是0xc0001500" class="headerlink" title="为什么是0xc0001500"></a>为什么是0xc0001500</h4><p><img src="/images/34.jpg" alt="34.jpg"></p>
<p>​    开启分页后0xc0001500在页表中对应的物理地址是0x00001500，loader在内存中的地址是0x900，而我们在loader中定义了GTD，所以内核代码不能覆盖loader，loader最大不超过2000个字节，0x900+2000=0x10d0，凑个整数，得到0x00001500，对应的虚拟地址为0xc0001500</p>
<h4 id="初始化内核的代码"><a href="#初始化内核的代码" class="headerlink" title="初始化内核的代码"></a>初始化内核的代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line">   <span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line"><span class="comment">;构建gdt及其内部的描述符</span></span><br><span class="line"><span class="symbol">   GDT_BASE:</span>   <span class="built_in">dd</span>    <span class="number">0x00000000</span> </span><br><span class="line">	       <span class="built_in">dd</span>    <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   CODE_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span> </span><br><span class="line">	       <span class="built_in">dd</span>    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   DATA_STACK_DESC:</span>  <span class="built_in">dd</span>    <span class="number">0x0000FFFF</span></span><br><span class="line">		     <span class="built_in">dd</span>    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="symbol">   VIDEO_DESC:</span> <span class="built_in">dd</span>    <span class="number">0x80000007</span>	       <span class="comment">; limit=(0xbffff-0xb8000)/4k=0x7</span></span><br><span class="line">	       <span class="built_in">dd</span>    DESC_VIDEO_HIGH4  <span class="comment">; 此时dpl为0</span></span><br><span class="line"></span><br><span class="line">   GDT_SIZE   <span class="built_in">equ</span>   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   <span class="built_in">equ</span>   GDT_SIZE -	<span class="number">1</span> </span><br><span class="line">   <span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span>					 <span class="comment">; 此处预留60个描述符的空位(slot)</span></span><br><span class="line">   SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0         <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">   SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上</span></span><br><span class="line">   SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0	 <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span></span><br><span class="line">   <span class="comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span></span><br><span class="line">   <span class="comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span></span><br><span class="line">   total_mem_bytes <span class="built_in">dd</span> <span class="number">0</span>					 </span><br><span class="line">   <span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span></span><br><span class="line">   gdt_ptr  <span class="built_in">dw</span>  GDT_LIMIT </span><br><span class="line">	    <span class="built_in">dd</span>  GDT_BASE</span><br><span class="line"></span><br><span class="line">   <span class="comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span></span><br><span class="line">   ards_buf <span class="built_in">times</span> <span class="number">244</span> <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">   ards_nr <span class="built_in">dw</span> <span class="number">0</span>		      <span class="comment">;用于记录ards结构体数量</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   loader_start:</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局  -------</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		      <span class="comment">;第一次调用时，ebx值要为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span>	      <span class="comment">;edx只赋值一次，循环体中不会改变</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf	      <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">.e820_mem_get_loop:</span>	      <span class="comment">;循环获取每个ARDS内存范围描述结构</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0000e820</span>	      <span class="comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>		      <span class="comment">;ARDS地址范围描述符结构大小是20字节</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e820_failed_so_try_e801   <span class="comment">;若cf位为1则有错误发生，尝试0xe801子功能</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>		      <span class="comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr]	      <span class="comment">;记录ARDS数量</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>		      <span class="comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span></span><br><span class="line">   <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line"><span class="comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]	      <span class="comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf </span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		      <span class="comment">;edx为最大的内存容量,在此先清0</span></span><br><span class="line"><span class="symbol">.find_max_mem_area:</span>	      <span class="comment">;无须判断type是否为1,最大的内存块一定是可被使用</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	      <span class="comment">;base_add_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">8</span>]	      <span class="comment">;length_low</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span>		      <span class="comment">;指向缓冲区中下一个ARDS结构</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span></span><br><span class="line">   <span class="keyword">jge</span> .next_ards</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>		      <span class="comment">;edx为总内存大小</span></span><br><span class="line"><span class="symbol">.next_ards:</span></span><br><span class="line">   <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span></span><br><span class="line"><span class="comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span></span><br><span class="line"><span class="comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span></span><br><span class="line"><span class="symbol">.e820_failed_so_try_e801:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xe801</span></span><br><span class="line">   <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .e801_failed_so_try88   <span class="comment">;若当前e801方法失败,就尝试0x88方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0x400</span>	     <span class="comment">;cx和ax值一样,cx用做乘数</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span> </span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>,<span class="number">16</span></span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span> <span class="comment">;ax只是15MB,故要加1MB</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">edx</span>	     <span class="comment">;先把低15MB的内存容量存入esi寄存器备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>		</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span>	<span class="comment">;0x10000十进制为64KB</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">ecx</span>		<span class="comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>		<span class="comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">esi</span>		<span class="comment">;edx为总内存大小</span></span><br><span class="line">   <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span></span><br><span class="line"><span class="symbol">.e801_failed_so_try88:</span> </span><br><span class="line">   <span class="comment">;int 15后，ax存入的是以kb为单位的内存容量</span></span><br><span class="line">   <span class="keyword">mov</span>  <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line">   <span class="keyword">int</span>  <span class="number">0x15</span></span><br><span class="line">   <span class="keyword">jc</span> .error_hlt</span><br><span class="line">   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x0000FFFF</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span>     <span class="comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span></span><br><span class="line">   <span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line">   <span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span>	     <span class="comment">;把dx移到高16位</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span>	     <span class="comment">;把积的低16位组合到edx,为32位的积</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">0x100000</span>  <span class="comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.mem_get_ok:</span></span><br><span class="line">   <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span>	 <span class="comment">;将内存换为byte单位后存入total_mem_bytes处。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   准备进入保护模式   -------------------</span></span><br><span class="line"><span class="comment">;1 打开A20</span></span><br><span class="line"><span class="comment">;2 加载gdt</span></span><br><span class="line"><span class="comment">;3 将cr0的pe位置1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  打开A20  ----------------</span></span><br><span class="line">   <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0x92</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0000_0010B</span></span><br><span class="line">   <span class="keyword">out</span> <span class="number">0x92</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  加载GDT  ----------------</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   <span class="comment">;-----------------  cr0第0位置1  ----------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">jmp</span> <span class="built_in">dword</span> SELECTOR_CODE:p_mode_start	     <span class="comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span></span><br><span class="line">					     <span class="comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span></span><br><span class="line"><span class="symbol">.error_hlt:</span>		      <span class="comment">;出错则挂起</span></span><br><span class="line">   <span class="keyword">hlt</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>,LOADER_STACK_TOP</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------   加载kernel  ----------------------</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, KERNEL_START_SECTOR        <span class="comment">; kernel.bin所在的扇区号</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR       <span class="comment">; 从磁盘读出后，写入到ebx指定的地址</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">200</span>			       <span class="comment">; 读入的扇区数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">call</span> rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 创建页目录及页表并初始化页内存位图</span></span><br><span class="line">   <span class="keyword">call</span> setup_page</span><br><span class="line"></span><br><span class="line">   <span class="comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span></span><br><span class="line">   <span class="keyword">sgdt</span> [gdt_ptr]	      <span class="comment">; 存储到原来gdt所有的位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [gdt_ptr + <span class="number">2</span>]  </span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">0x18</span> + <span class="number">4</span>], <span class="number">0xc0000000</span>      <span class="comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span></span><br><span class="line">					      <span class="comment">;段描述符的高4字节的最高位是段基址的31~24位</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">dword</span> [gdt_ptr + <span class="number">2</span>], <span class="number">0xc0000000</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">0xc0000000</span>        <span class="comment">; 将栈指针同样映射到内核地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr3</span>, eaxx</span><br><span class="line"></span><br><span class="line">   <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;在开启分页后,用gdt新的地址重新加载</span></span><br><span class="line">   <span class="keyword">lgdt</span> [gdt_ptr]             <span class="comment">; 重新加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span></span><br><span class="line"><span class="comment">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span></span><br><span class="line">   <span class="keyword">jmp</span> SELECTOR_CODE:enter_kernel	  <span class="comment">;强制刷新流水线,更新gdt</span></span><br><span class="line"><span class="symbol">enter_kernel:</span>    </span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">   <span class="keyword">call</span> kernel_init</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="number">0xc009f000</span></span><br><span class="line">   <span class="keyword">jmp</span> KERNEL_ENTRY_POINT                 <span class="comment">; 用地址0x1500访问测试，结果ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span></span><br><span class="line"><span class="symbol">kernel_init:</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>		<span class="comment">;ebx记录程序头表地址</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>		<span class="comment">;cx记录程序头表中的program header数量</span></span><br><span class="line">   <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>		<span class="comment">;dx 记录program header尺寸,即e_phentsize</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">dx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">42</span>]	  <span class="comment">; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">28</span>]   <span class="comment">; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span></span><br><span class="line">					  <span class="comment">; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cx</span>, [KERNEL_BIN_BASE_ADDR + <span class="number">44</span>]    <span class="comment">; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span></span><br><span class="line"><span class="symbol">.each_segment:</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">byte</span> [<span class="built_in">ebx</span> + <span class="number">0</span>], PT_NULL		  <span class="comment">; 若p_type等于 PT_NULL,说明此program header未使用。</span></span><br><span class="line">   <span class="keyword">je</span> .PTNULL</span><br><span class="line"></span><br><span class="line">   <span class="comment">;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">16</span>]		  <span class="comment">; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + <span class="number">4</span>]			  <span class="comment">; 距程序头偏移量为4字节的位置是p_offset</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, KERNEL_BIN_BASE_ADDR	  <span class="comment">; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">eax</span>				  <span class="comment">; 压入函数memcpy的第二个参数:源地址</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">dword</span> [<span class="built_in">ebx</span> + <span class="number">8</span>]			  <span class="comment">; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span></span><br><span class="line">   <span class="keyword">call</span> mem_cpy				  <span class="comment">; 调用mem_cpy完成段复制</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">12</span>				  <span class="comment">; 清理栈中压入的三个参数</span></span><br><span class="line"><span class="symbol">.PTNULL:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>				  <span class="comment">; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span></span><br><span class="line">   <span class="keyword">loop</span> .each_segment</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span></span><br><span class="line"><span class="comment">;输入:栈中三个参数(dst,src,size)</span></span><br><span class="line"><span class="comment">;输出:无</span></span><br><span class="line"><span class="comment">;---------------------------------------------------------</span></span><br><span class="line"><span class="symbol">mem_cpy:</span>		      </span><br><span class="line">   <span class="keyword">cld</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ecx</span>		   <span class="comment">; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]	   <span class="comment">; dst</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span> + <span class="number">12</span>]	   <span class="comment">; src</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">16</span>]	   <span class="comment">; size</span></span><br><span class="line">   <span class="keyword">rep</span> <span class="keyword">movsb</span>		   <span class="comment">; 逐字节拷贝</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">;恢复环境</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ecx</span>		</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------   创建页目录及页表   ---------------</span></span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line"><span class="comment">;先把页目录占用的空间逐字节清0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="comment">;开始创建页目录项(PDE)</span></span><br><span class="line"><span class="symbol">.create_pde:</span>				     <span class="comment">; 创建Page Directory Entry</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span> 			     <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>				     <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">					     <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">   <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>	     <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>				     <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P	     <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>				     <span class="comment">; 创建Page Table Entry</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>			     <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">loop</span> .create_pte</span><br><span class="line"></span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span> 		     <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">   <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性RW和P位为1,US为0</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>			     <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">   <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">			   <span class="comment">;功能:读取硬盘n个扇区</span></span><br><span class="line"><span class="symbol">rd_disk_m_32:</span>	   </span><br><span class="line"><span class="comment">;-------------------------------------------------------------------------------</span></span><br><span class="line">							 <span class="comment">; eax=LBA扇区号</span></span><br><span class="line">							 <span class="comment">; ebx=将数据写入的内存地址</span></span><br><span class="line">							 <span class="comment">; ecx=读入的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>	   <span class="comment">; 备份eax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">cx</span>		   <span class="comment">; 备份扇区数到di</span></span><br><span class="line"><span class="comment">;读写硬盘:</span></span><br><span class="line"><span class="comment">;第1步：设置要读取的扇区数</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>            <span class="comment">;读取的扇区数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span>	   <span class="comment">;恢复ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址7~0位写入端口0x1f3</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f3</span>                       </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span>                          x</span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址15~8位写入端口0x1f4</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">8</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f4</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">;LBA地址23~16位写入端口0x1f5</span></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f5</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">shr</span> <span class="built_in">eax</span>,<span class="built_in">cl</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x0f</span>	   <span class="comment">;lba第24~27位</span></span><br><span class="line">      <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xe0</span>	   <span class="comment">; 设置7～4位为1110,表示lba模式</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f6</span></span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第3步：向0x1f7端口写入读命令，0x20 </span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0x1f7</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0x20</span>                        </span><br><span class="line">      <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第4步：检测硬盘状态</span></span><br><span class="line"><span class="symbol">  .not_ready:</span>		   <span class="comment">;测试0x1f7端口(status寄存器)的的BSY位</span></span><br><span class="line">      <span class="comment">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">0x88</span>	   <span class="comment">;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span></span><br><span class="line">      <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x08</span></span><br><span class="line">      <span class="keyword">jnz</span> .not_ready	   <span class="comment">;若未准备好,继续等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;第5步：从0x1f0端口读数据</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span>	   <span class="comment">;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span></span><br><span class="line">			   <span class="comment">;在此先用这种方法,在后面内容会用到insw和outsw等</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span>	   <span class="comment">;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span></span><br><span class="line">      <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span>	   </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">  .go_on_read:</span></span><br><span class="line">      <span class="keyword">in</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>		</span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">ebx</span>], axx</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">			  <span class="comment">; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span></span><br><span class="line">			  <span class="comment">; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span></span><br><span class="line">			  <span class="comment">; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span></span><br><span class="line">			  <span class="comment">; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span></span><br><span class="line">			  <span class="comment">; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span></span><br><span class="line">			  <span class="comment">; 故程序出会错,不知道会跑到哪里去。</span></span><br><span class="line">			  <span class="comment">; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span></span><br><span class="line">			  <span class="comment">; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span></span><br><span class="line">			  <span class="comment">; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span></span><br><span class="line">			  <span class="comment">; 也会认为要执行的指令是32位.</span></span><br><span class="line">			  <span class="comment">; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span></span><br><span class="line">			  <span class="comment">; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x6x7，</span></span><br><span class="line">			  <span class="comment">; 临时改变当前cpu模式到另外的模式下.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span></span><br><span class="line">			  <span class="comment">; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">loop</span> .go_on_read</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h4 id="内核在低端1MB中的内存布局"><a href="#内核在低端1MB中的内存布局" class="headerlink" title="内核在低端1MB中的内存布局"></a>内核在低端1MB中的内存布局</h4><p><img src="/images/35.jpg" alt="35.jpg"></p>
<ul>
<li><p>0x900处开始是loader，其中loader的开始处是全局描述符表GTD，不能被覆盖，所以内核代码要安置到远离0x900较远的0x1000处（但是从0x1500处开始执行，0x1000到0x1500之间是elf header等内容）</p>
</li>
<li><p>可以看到MBR在0x7c00处，在内核之上，将来内核增大时，肯定会覆盖MBR的代码，不过这无关紧要，因为进入loader后MBR的使命已经完成，被覆盖也无关紧要</p>
</li>
<li><p>内核加载完成后，内核栈指针被设置成了0x9f000，即我们的内核代码在0x00001000到0x0009f000之间</p>
<p><img src="/images/34.jpg" alt="34.jpg"></p>
</li>
<li><p>从上图可以看出，低端1MB可用空间中最高地址是0x9FBFF，那么按理说内核栈指针可以设置到0x9fc00，而我们却选择了0x9f000，乍一看是浪费了0xc00字节的空间，其实不然，选则0x9f000为内核栈指针是因为每个PCB都是自然页，也就是4KB对齐，即类似0x000-0xfff这样，而不是类似0x333-0x1332这样的页内存块，而将来我们会在内核最高处设置内核进程的PCB，所有选择4k整数倍的地址0x9f000</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/os/" rel="tag"># os</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/11/保护模式之虚拟地址/" rel="next" title="保护模式之虚拟地址">
                <i class="fa fa-chevron-left"></i> 保护模式之虚拟地址
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Jiang Fan">
            
              <p class="site-author-name" itemprop="name">Jiang Fan</p>
              <p class="site-description motion-element" itemprop="description">不积跬步无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成内核"><span class="nav-number">1.</span> <span class="nav-text">生成内核</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内核源码"><span class="nav-number">1.1.</span> <span class="nav-text">内核源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译内核"><span class="nav-number">1.2.</span> <span class="nav-text">编译内核</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#编译main-c得到main-o"><span class="nav-number">1.2.1.</span> <span class="nav-text">编译main.c得到main.o</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链接main-o得到kernel-bin"><span class="nav-number">1.2.2.</span> <span class="nav-text">链接main.o得到kernel.bin</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机启动过程总结"><span class="nav-number">2.</span> <span class="nav-text">计算机启动过程总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF格式的二级制文件"><span class="nav-number">3.</span> <span class="nav-text">ELF格式的二级制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件类型"><span class="nav-number">3.1.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件布局"><span class="nav-number">3.2.</span> <span class="nav-text">文件布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF-header"><span class="nav-number">3.3.</span> <span class="nav-text">ELF header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Program-header-table"><span class="nav-number">3.4.</span> <span class="nav-text">Program header table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF文件实例分析"><span class="nav-number">3.5.</span> <span class="nav-text">ELF文件实例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将内核载入内存"><span class="nav-number">4.</span> <span class="nav-text">将内核载入内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么是0xc0001500"><span class="nav-number">4.1.</span> <span class="nav-text">为什么是0xc0001500</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化内核的代码"><span class="nav-number">4.2.</span> <span class="nav-text">初始化内核的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核在低端1MB中的内存布局"><span class="nav-number">4.3.</span> <span class="nav-text">内核在低端1MB中的内存布局</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Fan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
